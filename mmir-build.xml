<?xml version="1.0"?>
<!-- 
	This Ant-Build-File is for the generation of the directory structure in json format.generate
	It generates - for the directories specified in the property 'directoriesToParse' - a file (property 'outputDirectoryParseFileJson') with a json string.
-->
<project name="Mobile DialogSystem" default="build">
	
	<!-- ############# Initialization and Property Defintions ############# -->
	
	<property name="file.build.properties" value="mmir-build.properties" />
	<property name="file.build.settings" value="mmir-build.settings" />
	<property name="file.default.build.settings" value="mmir-build.settingsDefault" />
	
	<!-- create the settings-file (as a copy of the default settings) if not present: -->
	<!-- NOTE: 	granularity="9223372000000"
				is a WORKAROUND that ensures that ${file.build.settings} will not be overwritten,
				even if the default-settings-file is newer (it actually will only
				work as long as the settings-file is not older than ~ 292 years in comparison to
				the default-settings-file).
	-->
	<copy file="${file.default.build.settings}" tofile="${file.build.settings}" overwrite="false" granularity="9223372036854"/>
	
	<!-- if settings-file is not present, abort build: -->
	<available file="${file.build.settings}" property="is.build.settings.present"/>
	<fail unless="is.build.settings.present" message="Missing settings-file: ${file.build.settings}" />
	
	<!-- load settings and properties -->
	<property file="${file.build.settings}" />
	<property file="${file.build.properties}" />

	<property name="base.js.compile.grammar.parser.generator" value="${buildDirTempJS}${tempCompileGrammarParserGeneratorJSFile}" />
	<property name="exec.js.compile.grammar.parser.generator" value="${buildDirTempJS}${tempCompileGrammarParserGeneratorJSExecFile}" />

	<property name="exec.js.compile.template.parser" value="${buildDirTempJS}${tempCompileTemplateParserGeneratorJSExecFile}" />
	
	<property name="exec.nodejs" value="${nodeJsDir}${nodeJsExec}" />
	
	
	<property name="file.in.DialogEngine"  location="${SCXMLDialogEngineDir}${SCXMLDialogEngineXMLFile}" />
	<property name="file.in.InputEngine"   location="${SCXMLInputEngineDir}${SCXMLInputEngineXMLFile}" />
	<property name="file.out.DialogEngine" location="${JSOutDialogEngineDir}${SCXMLDialogEngineOutfile}" />
	<property name="file.out.InputEngine"  location="${JSOutInputEngineDir}${SCXMLInputEngineOutfile}" />
	<property name="compile.dialog.engine.err" location="${buildDirTempJS}dialog_engine.error.log"/>
	<property name="compile.input.engine.err"  location="${buildDirTempJS}input_engine.error.log"/>
	
	<!-- convert Strings to file references (where necessary): -->
	<property name="file.build.scxmljs.dir" location="${buildSCXMLJSDir}"/>

	<!-- ############# Include Ant Contrib Task (needed: foreach) ############# -->
	<taskdef resource="net/sf/antcontrib/antcontrib.properties">
		<classpath>
			<pathelement location="${buildDirLib}ant-contrib-1.0b3.jar"/>
		</classpath>
	</taskdef>
	
	
	<!-- ############# Main Build Targets ############# -->
	
	<target name="clean" depends="cleanTemp,cleanEngine,cleanGrammars" description="remove temporary and generated files (input-/dialog-engine, grammars)">
	</target>

	<target name="cleanTemp" description="remove intermediate files">
		<delete file="${outputDirectoryParseFileJson}"/>
	</target>
	
	<target name="cleanEngine" description="remove generated files for Inpute-/Dialog-Engine">
		<delete file="${file.out.DialogEngine}"/>
		<delete file="${file.out.InputEngine}"/>
	</target>
	
	<target name="cleanGrammars" depends="cleanTempFilesGrammarParserGenerator,cleanCompiledGrammarParserGeneratorDir" description="remove generated files for compiled grammars">
	</target>

	<!--
			DEFAULT build target:
			
			Creates/compiles all necessary files.
			Created compiled files currently encompass:
			 * directories.json (in assets/www/config/)
			 * JavaScript grammar files: [language-code]_grammar.js (in assets/www/gen/grammar/)
			
			NOTE: This target tries to use NodeJS as execution environment; 
			      if the NodeJS executable location cannot be verified, the Rhino envrionment is used 
			      (see ${file.build.settings} for NodeJS settings/paths and 
			       build.properties for Rhino (js-XX.jar) JAR path; 
			       the Rhino JAR should be included by default in build/libs/)
			
	  -->
	<target name="build" depends="checkNodeJsAvailable,generateFileListJSONFile" description="main build target">
		<echo>Running build, NodeJS not available?  ${is.not.available.nodejs}</echo>
		<antcall target="-callBuildRhino" inheritAll="true" inheritRefs="true">
			<param name="is.invoke.not.with.nodejs" value="${is.not.available.nodejs}"/>
		</antcall>
		<antcall target="-callBuildNodeJs" inheritAll="true" inheritRefs="true">
			<param name="is.invoke.not.with.nodejs" value="${is.not.available.nodejs}"/>
		</antcall>
	</target>
	
	<target name="buildNodeJs" depends="verifyNodeJsAvailable,generateFileListJSONFile,compileGrammarParserNodeJsEnvAllLanguages" description="main build target (using NodeJS)">
		<!-- Need to re-create filelist, since new files may have been created (or deleted).
			 NOTE that inheritAll needs to be false in order to force re-reading of directories/files.
		 -->
		<antcall target="generateFileListJSONFile" inheritAll="false" />
		<echo>Finished build (NODEJS).</echo>
	</target>
	
	<target name="buildRhino" depends="verifyRhinoAvailable,generateFileListJSONFileRhino,compileGrammarParserRhinoEnvAllLanguages" description="main build target (using Rhino)">
		<!-- Need to re-create filelist, since new files may have been created (or deleted).
			 NOTE that inheritAll needs to be false in order to force re-reading of directories/files.
		 -->
		<antcall target="generateFileListJSONFileRhino" inheritAll="false" />
		<echo>Finished build (RHINO).</echo>
	</target>
	
	<!--
			The following -call[specific-build-target] targets should not be triggered directly, but only from build-traget.
	
			The main difference between -call[specific-build-target] and [specific-build-target] is the added 
			check of property is.invoke.not.with.nodejs which is set in the calling build target.
	  -->
	<target name="-callBuildNodeJs" unless="${is.invoke.not.with.nodejs}">
		<antcall target="verifyNodeJsAvailable" />
		<antcall target="compileGrammarParserNodeJsEnvAllLanguages" />
		<antcall target="generateFileListJSONFile" inheritAll="false" />
		<echo>Finished build (NODEJS).</echo>
	</target>
	
	<target name="-callBuildRhino" if="${is.invoke.not.with.nodejs}">
		<antcall target="verifyRhinoAvailable" />
		<antcall target="compileGrammarParserRhinoEnvAllLanguages" />
		<antcall target="generateFileListJSONFileRhino" inheritAll="false" />
		<echo>Finished build (RHINO).</echo>
	</target>

	<!--
			This target compiles / creates all files for the USER APP that are genereted.
			
			In difference to the build target, this will also compile the InputEngine and 
			DialogEngine.
			The comiled versions of these SCXML files are no longer used when executing the
			application, but compilation may still be useful for finding syntax errors in the
			SCXML files.
			 
	  -->
	<target name="compileAllNodeJs" depends="buildNodeJs,generateDialogEngine,generateInputEngine" description="create/complile all generated files (NodeJS)">
		<echo>Finished compile task (NODEJS).</echo>
	</target>
	<target name="compileAllRhino" depends="buildRhino,generateDialogEngine,generateInputEngine" description="create/complile all generated files (Rhino)">
		<echo>Finished compile task (RHINO).</echo>
	</target>
	
	<!-- ############# Test Targets ############# -->
    <target name="test" depends="" description="runs all tests specified in test/drivers">
        <ant antfile="test.xml" target="test-all"/>
    </target>
	
    <!-- ############# Build Targets: Create JSON file with file-list ############# -->
	
	<target name="generateFileListJSONObject">
	    <property name="file.script.generate.filelist" location="${jsBuildDirBase}nodejs/CreateFileListGenerator.js"/>
		
		<echo message="Running node.js environment with script file &quot;${file.script.generate.filelist}&quot; and arguments &quot;${baseDir}&quot;, &quot;${directoriesToParse}&quot;" />
		<exec executable="${exec.nodejs}" failonerror="true" outputproperty="JSONDirString" logError="true">
			<arg value="${file.script.generate.filelist}"/>
			<arg value="${baseDir}"/>
            <arg value="${directoriesToParse}"/>
        </exec>
		<echo message="Language list for grammars: ${JSONDirString}" />
			
	</target>
	
	<target name="generateFileListJSONObjectRhino">
	    <property name="file.script.generate.filelist" location="${jsBuildDirBase}rhino/CreateFileListGenerator.js"/>
		
		<echo message="Running Rhino environment with script file &quot;${file.script.generate.filelist}&quot; and argument line &quot;-jar ${pathRhinoJar} -opt -1 ${exec.js.compile.grammar.parser.generator} ${baseDir} ${directoriesToParse}&quot;" />
		<exec executable="java" failonerror="true" outputproperty="JSONDirString" logError="true">
			<arg line="-jar ${pathRhinoJar} -opt -1 ${file.script.generate.filelist} ${baseDir} ${directoriesToParse}" />
        </exec>
		<echo message="Language list for grammars: ${JSONDirString}" />
			
	</target>
	
	<target name="generateFileListJSONFileRhino" depends="createGeneratedGrammarParserDir,createCompiledDialogEngineDir,createCompiledInputEngineDir,createGeneratedTemplateDir,generateFileListJSONObjectRhino">
		<echo>writing directory structure to file ${outputDirectoryParseFileJson}...</echo>
		<echo file="${outputDirectoryParseFileJson}">${JSONDirString}</echo>
		<echo>Created file ${outputDirectoryParseFileJson}.</echo>
	</target>
	
	<target name="generateFileListJSONFile" depends="createGeneratedGrammarParserDir,createCompiledDialogEngineDir,createCompiledInputEngineDir,createGeneratedTemplateDir,generateFileListJSONObject">
		<echo>writing directory structure to file ${outputDirectoryParseFileJson}...</echo>
		<echo file="${outputDirectoryParseFileJson}">${JSONDirString}</echo>
		<echo>Created file ${outputDirectoryParseFileJson}.</echo>
	</target>
	
	<!-- create gen-dir for generated template files (pre-compiled eHTML templates; see parse.xml) -->
	<target name="createGeneratedTemplateDir" description="Create base directory for generated/compiled eHTML template files">
		<mkdir dir="${outDirCompiledTemplate}"/>
	</target>
	
	<!-- create temp-dir for temporary / generated files during compiling -->
	<target name="createTempCompileDir" description="Create directory for temporary files">
	    <mkdir dir="${buildDirTempJS}" />
	</target>
	

	<!-- ############# Build ANT Templates Targets: create templates / ANT scripts that generate the base script for grammars/views ############# -->
	
	<!--
		NOTE these need to be executed when the grammar-/views-generator templates were changed in
		build/lib/mmir-lib/templates/*
	-->

	<import file="${antScriptGrammarsTemplate}"/>
	
	<property name="exec.js.compile.ant.grammars.template" value="${jsBuildDirBase}generator/build-standalone-grammar-gen.js" />
	<property name="exec.js.compile.ant.views.template" value="${jsBuildDirBase}generator/build-standalone-view-gen.js" />

	<target name="createBaseAntTemplates" depends="createBaseGrammarsAntTemplates,createBaseViewsAntTemplates">
		<echo message="created ANT generator templates." />
	</target>
	
	<target name="createBaseGrammarsAntTemplates" depends="checkNodeJsAvailable">
			
		<echo message="Running node.js environment with script file &quot;${exec.js.compile.ant.grammars.template}&quot; and argument &quot;true&quot;" />
		
		<exec executable="${exec.nodejs}" failonerror="true">
			<arg value="${exec.js.compile.ant.grammars.template}"/>
			<arg value="true"/>
        </exec>
		
		<echo message="created ANT generator template for grammars." />
		
	</target>
	
	<target name="createBaseViewsAntTemplates" depends="checkNodeJsAvailable">
			
		<echo message="Running node.js environment with script file &quot;${exec.js.compile.ant.views.template}&quot; and argument &quot;true&quot;" />
		
		<exec executable="${exec.nodejs}" failonerror="true">
			<arg value="${exec.js.compile.ant.views.template}"/>
			<arg value="true"/>
        </exec>
		
		<echo message="created ANT generator template for views." />
		
	</target>
	
	
	<!-- ############# Build Targets: compile DialogEngine (with up-to-date check) ############# -->

	<!--
				NOTE: 	Since SCION is used now for loading/interpreting SCXML files, comilation
						is not required only more.
						In fact, the compiled JS file is ignored (i.e. not included in the main index.html)
						
						However, compilation may still be useful for finding syntax errors in the SCXML file.  
	-->
	
	<target name="checkDialogEngineUpToDate">
		<condition property="is.up.to.date.DialogEngine" else="false">
	        
			<or>
				
				<!-- if ignoreDialogEngineGeneration is set to true,
				     then the DialogEngine should NEVER get compiled!
				-->
				<istrue value="${ignoreDialogEngineCompilation}"/>
				
				<and>
		            <!-- does (compiled) JavaScript file exist? -->
					<available file="${file.out.DialogEngine}"	     property="is.up.to.date.DialogEngine" />
				    
				    <!-- check, if the SCXML file has changed by its checksum -->
					<checksum
					    file="${file.in.DialogEngine}"
					    toDir="${JSOutDialogEngineDir}"
				    	fileExt=".checksum.txt"
				    	pattern="{0}&#09;"
					    verifyProperty="is.up.to.date.DialogEngine"/>
		        	
					<!-- if forceDialogEngineGeneration is set to true,
					     then the DialogEngine should ALWAYS get compiled,
					     even if it seems up-to-date!
					-->
		        	<not>
						<istrue value="${forceDialogEngineCompilation}"/>
					</not>
		        	
			    </and>
			    
			</or>
			
	    </condition>
		<echo>Is file ${file.out.DialogEngine} up-to-date? -> ${is.up.to.date.DialogEngine}</echo>
	</target>
	
	<target name="createCompiledDialogEngineDir" description="Create base directory for generated/generated SCXML JavaScript interpreter files">
		<mkdir dir="${JSOutDialogEngineDir}"/>
	</target>

	<target name="compileDialogEngine" depends="checkDialogEngineUpToDate,createTempCompileDir,createCompiledDialogEngineDir" unless="${is.up.to.date.DialogEngine}">
	    
		<delete file="${compile.dialog.engine.err}" />
		
		<java	
			classname="org.mozilla.javascript.tools.shell.Main"
			resultproperty="exec.dialog.engine.result" output="${file.out.DialogEngine}" error="${compile.dialog.engine.err}"
			logError="true">
			
			<arg line="-opt -1 ${file.build.scxmljs.dir}/runner.js ${file.build.scxmljs.dir} src/javascript/scxml/cgf/main --backend state --beautify --ie ${file.in.DialogEngine}"/>
										          
			<classpath>
	           <pathelement location="${pathRhinoJar}"/>
		       <pathelement location="${buildSCXMLJSDirLib}commons-cli-1.2.jar"/>
		       <pathelement location="${buildSCXMLJSDirLib}xalan-2.7.0.jar"/>
			   <pathelement location="${buildSCXMLJSDirLib}xercesImpl-2.9.1.jar"/>
			   <pathelement location="${buildSCXMLJSDirLib}xml-apis-2.0.2.jar"/>
	         </classpath>
	    </java>
		
		<condition property="compile.dialog.engine.failure" else="false">
			<not>
				<equals arg1="${exec.dialog.engine.result}" arg2="0" />
			</not>
		</condition>
	</target>
	
	<target name="compileDialogEngineSuccess" unless="${compile.dialog.engine.failure}">
		
		<checksum
		    file="${file.in.DialogEngine}"
		    toDir="${JSOutDialogEngineDir}"
			fileExt=".checksum.txt"
	    	pattern="{0}&#09;" />
		
		<echo>JavaScript DialogEngine file at ${file.out.DialogEngine}.</echo>
	</target>
	
	<target name="compileDialogEngineFail" if="${compile.dialog.engine.failure}" depends="createTempCompileDir">
		<loadresource property="compile.dialog.engine.err.out">
			<file file="${compile.dialog.engine.err}" />
		</loadresource>
		<echo>FAILED to generated file ${file.out.DialogEngine}.</echo>
		<fail message="Error: ${line.separator}${compile.dialog.engine.err}${line.separator}${compile.dialog.engine.err.out}">
		</fail>
	</target>
	
	<target name="generateDialogEngine" depends="compileDialogEngine,compileDialogEngineSuccess,compileDialogEngineFail">
	</target>


	<!-- ############# Build Targets: compile InputEngine (with up-to-date check) ############# -->
	
	<!--
			NOTE: 	Since SCION is used now for loading/interpreting SCXML files, comilation
					is not required only more.
					In fact, the compiled JS file is ignored (i.e. not included in the main index.html)
					
					However, compilation may still be useful for finding syntax errors in the SCXML file.  
	-->

	<target name="checkInputEngineUpToDate">
		<condition property="is.up.to.date.InputEngine" else="false">
	        
			<or>
							
				<!-- if ignoreInputEngineGeneration is set to true,
				     then the InputEngine should NEVER get compiled!
				-->
				<istrue value="${ignoreInputEngineCompilation}"/>
							
				<and>
		            
					<!-- does (compiled) JavaScript file exist? -->
					<available file="${file.out.InputEngine}"       property="is.up.to.date.InputEngine" />
				    
					<!-- has SCXML file changed? -->
					<checksum
					    file="${file.in.InputEngine}"
					    toDir="${JSOutInputEngineDir}"
						fileExt=".checksum.txt"
				    	pattern="{0}&#09;"
					    verifyProperty="is.up.to.date.InputEngine"/>
					
					<!-- if forceInputEngineGeneration is set to true,
					     then the InputEngine should ALWAYS get compiled,
					     even if it seems up-to-date!
					-->
		        	<not>
						<istrue value="${forceInputEngineCompilation}"/>
					</not>
		        	
			    </and>
				
			</or>
			
	    </condition>
		<echo>Is file ${file.out.InputEngine} up-to-date? -> ${is.up.to.date.InputEngine}</echo>
	</target>
	
	<target name="createCompiledInputEngineDir" description="Create base directory for generated/generated SCXML JavaScript interpreter files">
		<mkdir dir="${JSOutInputEngineDir}"/>
	</target>
	
	<target name="compileInputEngine" depends="checkInputEngineUpToDate,createTempCompileDir,createCompiledInputEngineDir" unless="${is.up.to.date.InputEngine}">

		<delete file="${compile.input.engine.err}" />
		
		<java	
			classname="org.mozilla.javascript.tools.shell.Main"
			resultproperty="exec.input.engine.result" output="${file.out.InputEngine}" error="${compile.input.engine.err}"
			logError="true">
			
			<arg line="-opt -1 ${file.build.scxmljs.dir}/runner.js ${file.build.scxmljs.dir} src/javascript/scxml/cgf/main --backend state --beautify --ie ${file.in.InputEngine}"/>
										          
			<classpath>
	           <pathelement location="${pathRhinoJar}"/>
		       <pathelement location="${buildSCXMLJSDirLib}commons-cli-1.2.jar"/>
		       <pathelement location="${buildSCXMLJSDirLib}xalan-2.7.0.jar"/>
			   <pathelement location="${buildSCXMLJSDirLib}xercesImpl-2.9.1.jar"/>
			   <pathelement location="${buildSCXMLJSDirLib}xml-apis-2.0.2.jar"/>
	         </classpath>
	    </java>
		
		<condition property="compile.input.engine.failure" else="false">
			<not>
				<equals arg1="${exec.input.engine.result}" arg2="0" />
			</not>
		</condition>
	</target>
	
	<target name="compileInputEngineSuccess" unless="${compile.input.engine.failure}">
		
		<checksum
		    file="${file.in.InputEngine}"
		    toDir="${JSOutInputEngineDir}"
			fileExt=".checksum.txt"
	    	pattern="{0}&#09;" />
		
		<echo>JavaScript InputEngine file at ${file.out.InputEngine}.</echo>
	</target>
	
	<target name="compileInputEngineFail" if="${compile.input.engine.failure}" depends="createTempCompileDir">
		<loadresource property="compile.input.engine.err.out">
			<file file="${compile.input.engine.err}" />
		</loadresource>
		<echo>FAILED to generated file ${file.out.InputEngine}.</echo>
		<fail message="Error: ${line.separator}${compile.input.engine.err}${line.separator}${compile.input.engine.err.out}">
		</fail>
	</target>
	
	<target name="generateInputEngine" depends="compileInputEngine,compileInputEngineSuccess,compileInputEngineFail">
	</target>
	
	<!--  ############# Build Targets: tasks for GrammarParser generation #############
				
				NOTE: 	Generation/compiling the GrammarParser via ANT is very slow.
						
						Using a modern browser (e.g. Firefox, Chrome) the HTML page 
							testSemanticInterpreter.html 
						generates the script considerably faster:
						ANT takes *minutes* whereas the browser/webpage generation takes *seconds*.
						
						When using ANT, note that the Rhino task is faster than using the task
						with the default JavaScript environment.
	 -->
	 
	<target name="cleanTempFilesGrammarParserGenerator" description="Clean temporary files that where created when compiling the GrammarParser">
		<echo message="Deleting temporary files in ${buildDirTempJS}..." />
        <delete dir="${buildDirTempJS}" />
	</target>
	

	<target name="-check-need-create-base-grammar-gen-file">

		<condition property="is.create.base.grammar.gen.file" else="false">
			        
			<or>
				<not>
					<istrue value="${is.create.files.only.if.not.exist}"/>
				</not>
				<and>
					<istrue value="${is.create.files.only.if.not.exist}"/>
					<not>
		    			<available property="is.create.base.grammar.gen.file" file="${base.js.compile.grammar.parser.generator}"/>
					</not>
				</and>
			</or>
			
		</condition>
		<echo message="is.create.base.grammar.gen.file -> ${is.create.base.grammar.gen.file}" />
		
	</target>
	
	<target name="-check-need-create-grammar-gen-file">

		<condition property="is.create.grammar.gen.file" else="false">
			        
			<or>
				<not>
					<istrue value="${is.create.files.only.if.not.exist}"/>
				</not>
				<and>
					<istrue value="${is.create.files.only.if.not.exist}"/>
					<not>
		    			<available property="is.create.grammar.gen.file" file="${exec.js.compile.grammar.parser.generator}"/>
					</not>
				</and>
			</or>
			
		</condition>
		<echo message="is.create.grammar.gen.file -> ${is.create.grammar.gen.file}" />
		
	</target>

	<target name="createGeneratedGrammarParserDir" description="Create base directory for generated semantic parser files">
		<mkdir dir="${outDirCompiledGrammar}"/>
	</target>

	<target name="cleanCompiledGrammarParserGeneratorDir" description="Clean directory for generated semantic parser files">
		<echo message="Deleting generated files in ${outDirCompiledGrammar}..." />
		<delete dir="${outDirCompiledGrammar}" />
	</target>

	<target name="checkGeneratedGrammarParserUpToDate">
		<condition property="is.up.to.date.grammarjs" else="false">
			<and>
				<!-- does (compiled) JavaScript file exist? -->
				<available 
			    	file="${outDirCompiledGrammar}${grammarLanguageCode}_${outFileCompiledGrammar}"
			    	property="is.up.to.date.grammarjs" />
				
				<or>
				    
				    <!-- if ignoreGrammarGeneration is set to true,
					     then the checksum/out-of-date check will be ignored.
					-->
					<istrue value="${ignoreGrammarChecksum}"/>
					
					<!-- 
						check, if the JSON file has changed by its checksum
						
						NOTE: this uses the checksum-file that is created by the JavaScript code
						      (which uses checksumUtils.js creating a file like: MD5<tab char><file size>)
					-->
					<checksum 
				    	file="${grammarDefinitionJsonDir}${grammarLanguageCode}/${grammarDefinitionJsonFile}"
				    	toDir="${outDirCompiledGrammar}"
				    	fileExt="_${grammarLanguageCode}.checksum.txt"
				    	pattern="{0}&#09;"
				    	verifyProperty="is.up.to.date.grammarjs"/>
				</or>
				
				<not>
					<istrue value="${forceGrammarGeneration}"/>
				</not>
			</and>
		</condition>
		<echo>Exists file ${outDirCompiledGrammar}${grammarLanguageCode}_${outFileCompiledGrammar}, and is file ${grammarDefinitionJsonDir}${grammarLanguageCode}/${grammarDefinitionJsonFile} up-to-date? -> ${is.up.to.date.grammarjs}</echo>
	</target>
	
	<!-- ############# Build Targets: GrammarParser generation with Mozilla Rhino JavaScript environment ############# 
			
			NOTE: this solution requires the Mozilla Rhino libarary to.
			
			WARNING: while this solution is faster than using the ANT default environment for running JavaScript,
					it is still very SLOW; however it has acceptable speed and is platform independent.
	-->
	
	<target name="checkRhinoAvailable" unless="${is.available.rhino}">
		<condition property="is.available.rhino" else="false">
			<not>
				<available file="${pathRhinoJar}"/>
			</not>
		</condition>
	</target>
	
	<target name="verifyRhinoAvailable" depends="checkRhinoAvailable" if="${is.available.rhino}">
		<fail message="Rhino library (JAR) is missing: invalid path ${pathRhinoJar}. Check / correct in file ${file.build.properties}.">
		</fail>
	</target>

	<target name="createGrammarLanguageListRhino" depends="generateFileListJSONFileRhino" description="create comma-separated list with language codes for available JSON grammar files">
					
		<property name="file.script.generate.languagelist" location="${jsBuildDirBase}rhino/CreateGrammarLanguageList.js"/>

		<echo message="Running Rhino environment with script file &quot;${exec.js.compile.grammar.parser.generator}&quot; and argument line &quot;-jar ${pathRhinoJar} -opt -1 ${file.script.generate.languagelist} ${grammarDefinitionJsonDir} ${grammarDefinitionJsonFile} ${outputDirectoryParseFileJson}&quot;" />
		<exec executable="java" failonerror="true" outputproperty="grammarLanguageList" logError="true">
			<arg line="-jar ${pathRhinoJar} -opt -1 ${file.script.generate.languagelist} ${grammarDefinitionJsonDir} ${grammarDefinitionJsonFile} ${outputDirectoryParseFileJson}" />
        </exec>
		<echo message="Language list for grammars: &quot;${grammarLanguageList}&quot;" />
		
	</target>
	
	<target name="createGrammarParserGeneratorScriptFileRhino" depends="verifyRhinoAvailable,createBaseParserScriptFileAnt,-check-need-create-grammar-gen-file" if="${is.create.grammar.gen.file}">
		<echo message="Building complete js file &quot;${exec.js.compile.grammar.parser.generator}&quot; for Rhino environment..." />
		<concat destfile="${exec.js.compile.grammar.parser.generator}" fixlastline="true" outputencoding="UTF-8">
			<fileset dir="${jsBuildDirBase}rhino" includes="InitRhinoEnv.js" />
			<fileset dir="${jsBuildDirBase}rhino" includes="InitGrammarGeneratorRhinoEnv.js" />
			<fileset dir="${jsBuildDirBase}ant"   includes="AntFileHandler.js" />
			<fileset file="${base.js.compile.grammar.parser.generator}" />
        </concat>
		<echo message="${exec.js.compile.grammar.parser.generator} built." />
	</target>
	
	<target name="executeGrammarParserGeneratorRhinoEnv"
		depends="checkGeneratedGrammarParserUpToDate"
		description="Compile GrammarParserGenerator script with Rhino environment (slow)"
		unless="${is.up.to.date.grammarjs}">

		<antcall target="-executeGrammarParserGeneratorRhinoEnv"/>
		
	</target>
	
	<target name="-executeGrammarParserGeneratorRhinoEnv"
		depends="createGeneratedGrammarParserDir,createGrammarParserGeneratorScriptFileRhino">

		<echo message="Running Rhino environment with script file &quot;${exec.js.compile.grammar.parser.generator}&quot; and argument line &quot;-jar ${pathRhinoJar} -opt -1 ${exec.js.compile.grammar.parser.generator} ${grammarDefinitionJsonDir} ${grammarDefinitionJsonFile} ${grammarLanguageCode} ${outDirCompiledGrammar} ${outFileCompiledGrammar} ${execBuildLibDir}&quot;" />
		<exec executable="java" failonerror="true">
			<arg line="-jar ${pathRhinoJar} -opt -1 ${exec.js.compile.grammar.parser.generator} ${grammarDefinitionJsonDir} ${grammarDefinitionJsonFile} ${grammarLanguageCode} ${outDirCompiledGrammar} ${outFileCompiledGrammar} ${execBuildLibDir}" />
        </exec>
	</target>
	
	<target name="compileGrammarParserRhinoEnv" depends="createGeneratedGrammarParserDir,createGrammarLanguageListRhino" description="Compile GrammarParserGenerator script with Rhino environment (slow) for a single language">
			
		<input
		    message="Select one of the following languages / codes for grammar generation:"
		    validargs="${grammarLanguageList}"
		    addproperty="selected.language"/>
	    
		<input
		    message="Select one of the following generators / grammar-engines for grammar generation:"
		    validargs="jscc,jison,pegjs"
			defaultvalue="jscc"
		    addproperty="selected.generator"/>
		
		<echo message="Using grammar-engine ${selected.generator} for compiling ${outDirCompiledGrammar}${selected.language}/${outFileCompiledGrammar} using Rhino environment..." />
				
		<antcall target="executeGrammarParserGeneratorRhinoEnv">
		    <param name="grammarLanguageCode" value="${selected.language}"/>
		    <param name="grammarEngine" value="${selected.generator}"/>
		    <param name="forceGrammarGeneration" value="true"/>
		</antcall>
		
	</target>
	
	<target name="compileGrammarParserRhinoEnvAllLanguages" depends="verifyRhinoAvailable,cleanTempFilesGrammarParserGenerator,createGeneratedGrammarParserDir,createGrammarLanguageListRhino" description="Compile (and clean up) GrammarParserGenerator scripts for all Languages with Rhino environment (slow)">
		<!-- NOTE: ${grammarJsonFileLanguageList} is generated by target createGrammarLanguageListRhino -->
		<property name="is.create.files.only.if.not.exist" value="true" />
		<foreach 
			list="${grammarLanguageList}" 
			delimiter=","
			target="executeGrammarParserGeneratorRhinoEnv" 
			param="grammarLanguageCode"
			inheritall="true"
		/>
	</target>

	<!-- ############# Build Targets: GrammarParser generation with node.js JavaScript environment ############# 
			
			This is the fastest available variant for executing JavaScript. 
			
			NOTE: this solution requires a platform dependent executable for node.js.
				  See the web page of node.js for executables for your platform (e.g. Windows, Mac, Linux). 
	-->
	
	
	<target name="checkNodeJsAvailableVersion" unless="${nodejs.version.is.set}">
		<!-- verify that nodejs is available by querying version information: -->
		<exec executable="${exec.nodejs}" failifexecutionfails="false" outputproperty="nodejs.version" resultproperty="exec.nodejs.version.result">
			<arg value="--version"/>
        </exec>

		<condition property="nodejs.version.is.set" else="false">
			<equals arg1="${exec.nodejs.version.result}" arg2="0" />
		</condition>
		
		<echo message="Using Node.js ${nodejs.version} ..."/>
	</target>
	
	<target name="checkNodeJsAvailable" depends="checkNodeJsAvailableVersion">
		<condition property="is.not.available.nodejs" else="false">
			<isfailure code="${exec.nodejs.version.result}"/>
		</condition>
	</target>
	
	<target name="verifyNodeJsAvailable" depends="checkNodeJsAvailable" if="${is.not.available.nodejs}">
		<fail message="Aborted: Node.js exectuable is missing and/or invalid path specified.${line.separator}Tested command line:${line.separator}${exec.nodejs} --version">
		</fail>
	</target>
	
	<target name="createGrammarLanguageList" depends="generateFileListJSONFile">
			
	    <property name="file.script.generate.languagelist" location="${jsBuildDirBase}nodejs/CreateGrammarLanguageList.js"/>
		
		<echo message="Running node.js environment with script file &quot;${file.script.generate.languagelist}&quot; and arguments &quot;${grammarDefinitionJsonDir}&quot;, &quot;${grammarDefinitionJsonFile}&quot;, &quot;${outputDirectoryParseFileJson}&quot;" />
		<exec executable="${exec.nodejs}" failonerror="true" outputproperty="grammarLanguageList" logError="true">
			<arg value="${file.script.generate.languagelist}"/>
			<arg value="${grammarDefinitionJsonDir}"/>
            <arg value="${grammarDefinitionJsonFile}"/>
			<arg value="${outputDirectoryParseFileJson}"/>
        </exec>
		<echo message="Language list for grammars: &quot;${grammarLanguageList}&quot;" />
				
	</target>
	
	<target name="createBaseParserScriptFileNodeJs" depends="checkNodeJsAvailable,createTempCompileDir,-check-need-create-base-grammar-gen-file" if="${is.create.base.grammar.gen.file}">
			
		<echo message="Running node.js environment with script file &quot;${exec.js.compile.ant.grammars.template}&quot; and no arguments" />
			
		<exec executable="${exec.nodejs}" failonerror="true">
			<arg value="${exec.js.compile.ant.grammars.template}"/>
        </exec>
		
		<echo message="created generator script for grammars." />
			
	</target>
	
	<target name="createGrammarParserGeneratorScriptFileNodeJs" depends="verifyNodeJsAvailable,createBaseParserScriptFileNodeJs,-check-need-create-grammar-gen-file" if="${is.create.grammar.gen.file}">
		
		<echo message="Building complete js file &quot;${exec.js.compile.grammar.parser.generator}&quot; for node.js environment..."/>
		<concat destfile="${exec.js.compile.grammar.parser.generator}" fixlastline="true" outputencoding="UTF-8">
			<fileset dir="${jsBuildDirBase}nodejs" includes="InitNodeJsEnv.js" />
			<fileset dir="${jsBuildDirBase}nodejs" includes="InitGrammarGeneratorNodeJsEnv.js" />
			<fileset dir="${jsBuildDirBase}nodejs" includes="NodeJsFileHandler.js" />
			<fileset file="${base.js.compile.grammar.parser.generator}" />
        </concat>
		<echo message="${exec.js.compile.grammar.parser.generator} built." />
	</target>
	
	
	<target name="executeGrammarParserGeneratorNodeJsEnv" 
		depends="checkGeneratedGrammarParserUpToDate" 
		description="Compile GrammarParserGenerator script with node.js environment (fast)"
		unless="${is.up.to.date.grammarjs}">

		<antcall target="-executeGrammarParserGeneratorNodeJsEnv"/>
		
	</target>
	
	<target name="-executeGrammarParserGeneratorNodeJsEnv" 
		depends="createGeneratedGrammarParserDir,createGrammarParserGeneratorScriptFileNodeJs">

		<echo message="Running node.js environment with script file &quot;${exec.js.compile.grammar.parser.generator}&quot; and arguments &quot;${grammarDefinitionJsonDir}&quot;, &quot;${grammarDefinitionJsonFile}&quot;, &quot;${grammarLanguageCode}&quot;, &quot;${outDirCompiledGrammar}&quot;, &quot;${outFileCompiledGrammar}&quot;, &quot;${execBuildLibDir}&quot;" />
		<exec executable="${exec.nodejs}" failonerror="true">
			<arg value="${exec.js.compile.grammar.parser.generator}"/>
			<arg value="${grammarDefinitionJsonDir}"/>
            <arg value="${grammarDefinitionJsonFile}"/>
			<arg value="${grammarLanguageCode}"/>
			<arg value="${outDirCompiledGrammar}"/>
            <arg value="${outFileCompiledGrammar}"/>
            <arg value="${execBuildLibDir}"/>
        </exec>
		
	</target>

	<target name="compileGrammarParserNodeJsEnv" depends="createGeneratedGrammarParserDir,createGrammarLanguageList" description="Compile GrammarParserGenerator script with node.js environment (fast) for a single language">
		
		<input
		    message="Select one of the following languages / codes for grammar generation:"
		    validargs="${grammarLanguageList}"
		    addproperty="selected.language"/>
	    
		<input
		    message="Select one of the following generators / grammar-engines for grammar generation:"
		    validargs="jscc,jison,pegjs"
			defaultvalue="jscc"
		    addproperty="selected.generator"/>
		
		<echo message="Using grammar-engine ${selected.generator} for compiling ${outDirCompiledGrammar}${selected.language}/${outFileCompiledGrammar} using node.js environment..." />
				
		<antcall target="executeGrammarParserGeneratorNodeJsEnv">
		    <param name="grammarLanguageCode" value="${selected.language}"/>
		    <param name="grammarEngine" value="${selected.generator}"/>
		    <param name="forceGrammarGeneration" value="true"/>
		</antcall>
		
	</target>
	
	<target name="compileGrammarParserNodeJsEnvAllLanguages" depends="verifyNodeJsAvailable,cleanTempFilesGrammarParserGenerator,createGeneratedGrammarParserDir,createGrammarLanguageList" description="Compile (and clean up) GrammarParserGenerator script for all Languages with node.js environment (fast)">
		<!-- NOTE: ${grammarJsonFileLanguageList} is generated by target createGrammarLanguageList -->
		
		<property name="is.create.files.only.if.not.exist" value="true" />
		<foreach 
			list="${grammarLanguageList}"
			delimiter=","
			target="executeGrammarParserGeneratorNodeJsEnv" 
			param="grammarLanguageCode"
			inheritall="true"
		/>
	</target>
	
	<!-- END: tasks for GrammarParser generation -->
	
</project>
