{
  "name": "properties",
  "version": "1.2.1",
  "description": ".properties parser/stringifier",
  "keywords": [
    "properties",
    "ini",
    "parser",
    "stringifier",
    "config"
  ],
  "author": {
    "name": "Gabriel Llamas",
    "email": "gagle@outlook.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/gagle/node-properties.git"
  },
  "engines": {
    "node": ">=0.10"
  },
  "devDependencies": {
    "ini": "1.1.x",
    "speedy": "*",
    "js-yaml": "3.13.x"
  },
  "scripts": {
    "test": "node test/parse && node test/stringify"
  },
  "license": "MIT",
  "main": "lib",
  "readme": "properties\r\n==========\r\n\r\n#### .properties parser/stringifier ####\r\n\r\n[![NPM version](https://badge.fury.io/js/properties.png)](http://badge.fury.io/js/properties \"Fury Version Badge\")\r\n[![Build Status](https://secure.travis-ci.org/gagle/node-properties.png)](http://travis-ci.org/gagle/node-properties \"Travis CI Badge\")\r\n\r\n[![NPM installation](https://nodei.co/npm/properties.png?mini=true)](https://nodei.co/npm/properties \"NodeICO Badge\")\r\n\r\n[.properties specification](http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29)\r\n\r\nThis module implements the Java .properties specification and adds additional features like [ini](#ini) sections, variables (key referencing), namespaces, importing files and much more.\r\n\r\n#### Quick example ####\r\n\r\n```\r\n# file\r\na = 1\r\nb: 2\r\n```\r\n\r\n```javascript\r\nvar properties = require (\"properties\");\r\n\r\nproperties.parse (\"file\", { path: true }, function (error, obj){\r\n  if (error) return console.error (error);\r\n  \r\n  console.log (obj);\r\n  //{ a: 1, b: 2 }\r\n});\r\n```\r\n\r\n#### Documentation ####\r\n\r\n- [Sections](#sections)\r\n- [Variables](#variables)\r\n  - [Environment](#environment)\r\n- [Namespaces](#namespaces)\r\n- [INI](#ini)\r\n- [Importing files](#include)\r\n- [Useful options that you should always use](#useful)\r\n\r\n#### Functions ####\r\n\r\n- [_module_.parse(data[, options][, callback]) : undefined | Object](#parse)\r\n- [_module_.createStringifier() : Stringifier](#createStringifier)\r\n- [_module_.stringify(obj[, options][, callback]) : undefined | String](#stringify)\r\n\r\n#### Objects ####\r\n\r\n- [Stringifier](#Stringifier)\r\n\r\n---\r\n\r\n<a name=\"sections\"></a>\r\n__Sections__\r\n\r\nINI sections can be enabled with the `sections` option. With them you can better organize your configuration data.\r\n\r\n```\r\napp_name App\r\n\r\n[web]\r\nhostname 10.10.10.10\r\nport 1234\r\n\r\n[db]\r\nhostname 10.10.10.20\r\nport 4321\r\n```\r\n\r\nCreates:\r\n\r\n```javascript\r\n{\r\n  app_name: \"App\",\r\n  web: {\r\n    hostname: \"10.10.10.10\",\r\n    port: 1234\r\n  },\r\n  db: {\r\n    hostname: \"10.10.10.20\",\r\n    port: 4321\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n<a name=\"variables\"></a>\r\n__Variables__\r\n\r\nWhen the `variables` option is enabled you can get the value of another key. The value is read __before__ the type conversion. Imagine them like the C macros. They simply copy the characters, they don't care if the value is a number or a string.\r\n\r\n```\r\na = 1\r\n# b = 1\r\nb = ${a}\r\n```\r\n\r\nNote: If you are using the `include` option, take into account that the variables are local to the file, they cannot be used to access the properties of other files.\r\n\r\nIf you need to get the value of a key that belongs to a section, prefix the key with the section followed by `|`.\r\n\r\n```\r\na = 1\r\n[section]\r\na = 2\r\n# b = 2\r\nb = ${section|a}\r\n```\r\n\r\nYou can use the variables anywhere including the variable itself. Look at the [variables](https://github.com/gagle/node-properties/blob/master/examples/variables/variables.js) example for further details.\r\n\r\n```\r\na = 1\r\n# s1\r\n[s${a}]\r\na = b\r\nb = c\r\n# d = c\r\nd = ${s${a}|${s${a}|a}}\r\n```\r\n\r\n<a name=\"environment\"></a>\r\n__Environment__\r\n\r\nYou can also pass external variables with the `vars` option and use their value while the file is being parsed. This is an extremly useful feature because you don't need to change anything from your configuration files if you want to dynamically assign the value of the properties. It could be used to load different configurations depending on the environment. Look at the [vars](https://github.com/gagle/node-properties/blob/master/examples/variables/vars.js) and [environment-vars](https://github.com/gagle/node-properties/blob/master/examples/variables/environment-vars.js) examples for further details.\r\n\r\n---\r\n\r\n<a name=\"namespaces\"></a>\r\n__Namespaces__\r\n\r\nWhen the `namespaces` option is enabled dot separated keys and sections are parsed as namespaces, that is, they are interpreted as JavaScript objects.\r\n\r\n```\r\na.b = 1\r\na.c.d = 2\r\n\r\n```\r\n\r\nThese properties create the following object:\r\n\r\n```javascript\r\n{\r\n  a: {\r\n    b: 1,\r\n    c: {\r\n      d: 2\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nYou can also use sections and variables:\r\n\r\n```\r\n[s1.x]\r\na.b = 1\r\n# a.c.d = 1\r\na.c.d = ${s1.x|a.b}\r\n\r\n```\r\n\r\n```javascript\r\n{\r\n  s1: {\r\n    x: {\r\n      a: {\r\n        b: 1,\r\n        c: {\r\n          d: 1\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe external variables can be also read using namespaces:\r\n\r\n```javascript\r\nvar options = {\r\n  vars: {\r\n    a: {\r\n      b: 1\r\n    }\r\n  }\r\n};\r\n```\r\n\r\n```\r\n# a = 1\r\na = ${a.b}\r\n```\r\n\r\nLook at the [namespaces](https://github.com/gagle/node-properties/blob/master/examples/namespaces/namespaces.js) example for further details.\r\n\r\n---\r\n\r\n<a name=\"ini\"></a>\r\n__INI__\r\n\r\nThis module implements the .properties specification but there are some options that can be enabled, some of them are the `sections`, `comments`, `separators` and `strict`. With these four options this module can parse INI files. There isn't an official INI specification, each program implements its own features, but there is a de facto standard that says that INI files are just .properties files with sections and the `=` token as a separator.\r\n\r\nIf you want to parse INI files, then enable these options:\r\n\r\n```javascript\r\nvar options = {\r\n  sections: true,\r\n  comments: \";\", //Some INI files also consider # as a comment, if so, add it, comments: [\";\", \"#\"]\r\n  separators: \"=\",\r\n  strict: true\r\n};\r\n```\r\n\r\nThe `strict` option says that __only__ the tokens that are specified in the `comments` and `separators` options are used to parse the file. If `strict` is not enabled, the default .properties comment (`#`, `!`) and separator (`=`, `:`) tokens are also used to parse comments and separators. Look at the [ini](https://github.com/gagle/node-properties/tree/master/examples/ini) examples for further details.\r\n\r\nNote: The whitespace (`<space>`, `\\t`, `\\f`) is still considered a separator even if `strict` is true.\r\n\r\n---\r\n\r\n<a name=\"include\"></a>\r\n__Importing files__\r\n\r\nWhen the `include` option is enabled, the `include` key allow you import files. If the path is a directory, it tries to load the file `index.properties`. The paths are relative to the __current__ .properties file.\r\n\r\nThe imported files are merged with the current file, they can replace old data.\r\n\r\nThe _include_ keyword cannot appear inside a section, it must be a global property.\r\n\r\n```\r\ninclude a/file\r\n\r\n# Load a/dir/index.properties\r\ninclude a/dir\r\n```\r\n\r\nNote: You can include files using a simple key-value string:\r\n\r\n```javascript\r\nproperties.parse (\"include my/file\", function (error, data){\r\n\t...\r\n})\r\n```\r\n\r\nIn this case the files are __always__ relative to `.`. You cannot use `__dirname` like this: `\"include \" + __dirname + \"/my/file\"`.\r\n\r\n---\r\n\r\n<a name=\"useful\"></a>\r\n__Useful options that you should always use__\r\n\r\nThere are too many options that you can enable but, which of them should you use? Well, this depends on what you need but I like to enable the following ones:\r\n\r\n- __namespaces__: Extremly useful if you want to organize your configuration files using namespaces and access the data using JavaScript objects. For example:\r\n  \r\n  ```\r\n  db.pool.min 5\r\n  db.pool.max 10\r\n  ```\r\n\r\n  Instead of:\r\n  \r\n  ```\r\n  db_pool_min 5\r\n  db_pool_max 10\r\n  ```\r\n- __sections__: More organization. You don't need to write all the namespace chain. For example:\r\n\r\n  ```\r\n  [db]\r\n  host 1.2.3.4\r\n  port 1234\r\n  \r\n  [db.pool]\r\n  min 5\r\n  max 10\r\n  ```\r\n  \r\n  Instead of:\r\n  \r\n  ```\r\n  db.host 1.2.3.4\r\n  db.port 1234\r\n  db.pool.min 5\r\n  db.pool.max 10\r\n  ```\r\n- __variables__: Writing the same thing again and again is a bad practice. Write it once and use a variable to copy the value wherever you want. With the variables enabled you can pass external variables to the file using the __vars__ option, which is pretty useful as shown in the [environment-vars](https://github.com/gagle/node-properties/blob/master/examples/variables/environment-vars.js) example.\r\n- __include__: Even more organization. I don't like to have a huge configuration file, I tend to have multiple smaller files. With this option I don't need to load all the files, I simply load the index file which includes all the files.\r\n\r\nWrapping this module it's also a good idea. This is a good starting point:\r\n\r\n```javascript\r\n//config.js\r\n\r\nvar properties = require (\"properties\");\r\n\r\nvar options = {\r\n  path: true,\r\n  namespaces: true,\r\n  sections: true,\r\n  variables: true,\r\n  include: true\r\n};\r\n\r\nvar configDir = \"./path/to/config/dir\";\r\n\r\nmodule.exports.load = function (path, cb){\r\n  //NODE_ENV can be \"production\" or \"development\"\r\n  //Load specific configuration depending on the environment\r\n  properties.parse (configDir + \"/\" + process.env.NODE_ENV, options,\r\n      function (error, env){\r\n    if (error) return cb (error);\r\n    \r\n    //Pass the specific configuration as external variables to the common\r\n    //configuration\r\n    options.vars = env;\r\n    \r\n    //If the path is a directory it tries to load the \"index.properties\" file\r\n    properties.parse (configDir, options, cb);\r\n  });\r\n};\r\n```\r\n\r\nUsage:\r\n\r\n```javascript\r\nvar config = require (\"./config\");\r\n\r\nconfig.load (function (error, obj){\r\n  if (error) return console.error (error);\r\n  \r\n  ...\r\n});\r\n```\r\n\r\nNote: You can also use a configuration loader like [seraphim](https://github.com/gagle/node-seraphim).\r\n\r\n---\r\n\r\n<a name=\"parse\"></a>\r\n___module_.parse(data[, options][, callback]) : undefined | Object__  \r\n\r\nParses a .properties string.\r\n\r\nIf a callback is given, the result is returned as the second parameter. Some options will require a callback.\r\n\r\n```javascript\r\ntry{\r\n  //Certain options can throw errors, so if the callback is not used, try-catch\r\n  //the function\r\n  obj = properties.parse ({ ... });\r\n}catch (error){\r\n  ...\r\n}\r\n\r\nproperties.parse ({ ... }, function (error, obj){\r\n  //The callback must be used if the \"path\" option is used\r\n});\r\n```\r\n\r\nOptions:\r\n\r\n- __path__ - _Boolean_  \r\n  By default `parse()` reads a String. If you want to read a file, set this option to true. If this option is used, the callback is mandatory. It gets 2 parameters, a possible error and the object with all the properties.\r\n- __comments__ - _String_ | _Array_  \r\n  Allows you to add additional comment tokens. The token must be a single printable non-whitespae ascii character. If the `strict` option is not set, the tokens `#` and `!` are parsed as comment tokens.\r\n  \r\n  ```javascript\r\n  comments: \";\"\r\n  comments: [\";\", \"@\"]\r\n  ```\r\n- __separators__ - _String_ | _Array_  \r\n  Allows you to add additional separator tokens. The token must be a single printable non-whitespae ascii character. If the `strict` option is not set, the tokens `=` and `:` are parsed as comment tokens.\r\n  \r\n  ```javascript\r\n  separators: \"-\"\r\n  separators: [\"-\", \">\"]\r\n  ```\r\n- __strict__ - _Boolean_  \r\n  This option can be used with the `comments` and `separators` options. If true, __only__ the tokens specified in these options are used to parse comments and separators.\r\n- __sections__ - _Boolean_  \r\n  Parses INI sections. Read the [INI](#ini) section for further details.\r\n- __namespaces__ - _Boolean_  \r\n  Parses dot separated keys as JavaScript objects. Look at the [namespaces](#namespaces) section for further details.\r\n- __variables__ - _Boolean_  \r\n  Allows you to read the value of a key while the file is being parsed. Look at the [variables](#variables) section for further details.\r\n- __vars__ - _Boolean_  \r\n  External variables can be passed to the file if the variables option is enabled. Look at the [variables](#variables) section for further details.\r\n- __include__ - _Boolean_  \r\n  Files can be linked and imported with the `include` key. If this option is used, the callback is mandatory. Look at the [include](#include) section for further details.\r\n- __reviver__ - _Function_  \r\n  Each property or section can be removed or modified from the final object. It's similar to the reviver of the `JSON.parse()` function.\r\n\r\n  The reviver it's exactly the same as the replacer from [stringify()](#stringify). The same function can be reused.\r\n\r\n  The callback gets 3 parameters: key, value and section.\r\n  \r\n  A property has a key and a value and can belong to a section. If it's a global property, the section is set to null. If __undefined__ is returned, the property will be removed from the final object, otherwise the returned value will be used as the property value.\r\n  \r\n  If the key and the value are set to null, then it's a section line. If it returns a falsy value, it won't be added to the final object, the entire section -including all the properties- will be discarded. If it returns a truthy value, the section is parsed.\r\n  \r\n  For your convenience, to know whether the line is a property or section you can access to `this.isProperty` and `this.isSection` from inside the replacer function. Also, `this.assert()` can be used to return the _default_ value, the unmodified value that will be used to parse the line.\r\n  \r\n  `this.assert()` it's the same as:\r\n  \r\n    ```javascript\r\n    if (this.isProperty){\r\n      return value;\r\n    }else{\r\n      //isSection\r\n      return true;\r\n    }\r\n    ```\r\n  \r\n  For example, a reviver that does nothing and a reviver that removes all the lines:\r\n  \r\n    ```javascript\r\n    function (key, value, section){\r\n      //Returns all the lines\r\n      return this.assert ();\r\n    }\r\n    ```\r\n    \r\n    ```javascript\r\n    function (key, value, section){\r\n      //Removes all the lines\r\n    }\r\n    ```\r\n  \r\n  The reviver is called just after the value is casted to the proper data type. This means that the `value` parameter can be null, true, false or any data type.\r\n  \r\n  This module doesn't parse arrays but you can actually parse comma-separated values using a reviver:\r\n  \r\n  ```javascript\r\n  var options = {\r\n    sections: true,\r\n    reviver: function (key, value, section){\r\n      //Do not split section lines\r\n      if (this.isSection) return this.assert ();\r\n      \r\n      //Split all the string values by a comma\r\n      if (typeof value === \"string\"){\r\n        var values = value.split (\",\");\r\n        return values.length === 1 ? value : values;\r\n      }\r\n      \r\n      //Do not split the rest of the lines\r\n      return this.assert ();\r\n    }\r\n  };\r\n  \r\n  /*\r\n  [sec,tion]\r\n  key1 a,b,c\r\n  key2 true\r\n  */\r\n  console.log (properties.parse (\"[sec,tion]\\n key1 a,b,c\\n key2 true\", options));\r\n  \r\n  /*\r\n  {\r\n    \"sec,tion\": {\r\n      key1: [\"a\", \"b\", \"c\" ],\r\n      key2: true\r\n    }\r\n  }\r\n  */\r\n  ```\r\n  \r\n  Look at the [reviver](https://github.com/gagle/node-properties/blob/master/examples/reviver/reviver.js) example for further details.\r\n\r\n---\r\n\r\n<a name=\"createStringifier\"></a>\r\n___module_.createStringifier() : Stringifier__\r\n\r\nReturns a new [Stringifier](#Stringifier) instance.\r\n\r\n---\r\n\r\n<a name=\"stringify\"></a>\r\n___module_.stringify(obj[, options][, callback]) : undefined | String__\r\n\r\nStringifies an object or a [Stringifier](#Stringifier).\r\n\r\nIf you don't need to add sections or comments simply pass an object, otherwise use a [Stringifier](#Stringifier).\r\n\r\nThe callback is only necessary when the `path` option is used.\r\n\r\nNested objects and arrays cannot be stringified like in JSON.stringify:\r\n\r\n```javascript\r\nproperties.stringify ({\r\n  a: [1, \"a\"],\r\n  b: {}\r\n});\r\n\r\n/*\r\na = 1,a\r\nb = [object Object]\r\n*/\r\n```\r\n\r\nThis also applies to the [Stringifier](#Stringifier) keys and values.\r\n\r\nOptions:\r\n\r\n- __path__ - _String_  \r\n  By default `stringify()` returns a string. If you want to write it to a file, use this option and pass the path of a file. If this option is used, the callback is mandatory. It gets two parameters, a possible error and the string.\r\n- __comment__ - _String_  \r\n  The token to use to write comments. It must be a single printable non-whitespace ascii character. Default is `#`.\r\n- __separator__ - _String_  \r\n  The token to use to separate keys from values. It must be a single printable non-whitespace ascii character. Default is `=`.\r\n- __unicode__ - _Boolean_  \r\n  The .properties specification uses iso 8859-1 (latin-1) as a default encoding. In the other hand, Node.js has a utf8 default encoding. This means that if you want a full compatibility with Java, that is, you are generating a .properties file that is going to be read by a Java program, then set this option to true. This will encode all ascii extended and multibyte characters to their unicode string representation (`\\uXXXX`).\r\n\r\n  Non-printable control codes (control sets 0 and 1) are always encoded as unicode strings except `\\t`, `\\n`, `\\f` and `\\r`.\r\n  \r\n  If you are in a platform that can handle utf8 strings, e.g. Node.js, you don't need to use this option.\r\n- __replacer__ - _Function_  \r\n  Each property or section can be removed or modified from the final string. It's similar to the replacer of the `JSON.stringify()` function.\r\n\r\n  The replacer it's exatcly the same as the reviver from [parse()](#parse). The same function can be reused.\r\n\r\n  The callback gets three parameters: key, value and section.\r\n  \r\n  A property has a key and a value and can belong to a section. If it's a global property, the section is set to null. If __undefined__ is returned, the property won't be stringified, otherwise the returned value will be used as the property value.\r\n  \r\n  If the key and the value are set to null, then it's a section line. If it returns a falsy value, it won't be added to the final string, the entire section -including all the properties- will be discarded. If it returns a truthy value, the section is stringified.\r\n  \r\n  For your convenience, to know whether the line is a property or section you can access to `this.isProperty` and `this.isSection` from inside the replacer function. Also, `this.assert()` can be used to return the _default_ value, the unmodified value that will be used to stringify the line.\r\n  \r\n  `this.assert()` it's the same as:\r\n  \r\n    ```javascript\r\n    if (this.isProperty){\r\n      return value;\r\n    }else{\r\n      //isSection\r\n      return true;\r\n    }\r\n    ```\r\n  \r\n  For example, a replacer that does nothing and a replacer that removes all the lines:\r\n    \r\n    ```javascript\r\n    function (key, value, section){\r\n      //Returns all the lines\r\n      return this.assert ();\r\n    }\r\n    ```\r\n    \r\n    ```javascript\r\n    function (key, value, section){\r\n      //Removes all the lines\r\n    }\r\n    ```\r\n  \r\n  Look at the [replacer](https://github.com/gagle/node-properties/blob/master/examples/replacer.js) example for further details.\r\n\r\n---\r\n\r\n<a name=\"Stringifier\"></a>\r\n__Stringifier__\r\n\r\nThis class is used when you want to add sections or comments to the final string.\r\n\r\nTo create a Stringifier use the [createStringifier()](#createStringifier) function.\r\n\r\n__Methods__\r\n\r\n- [Stringifier#header(comment) : Stringifier](#Stringifier_header)\r\n- [Stringifier#property(obj) : Stringifier](#Stringifier_property)\r\n- [Stringifier#section(obj) : Stringifier](#Stringifier_section)\r\n\r\n<a name=\"Stringifier_header\"></a>\r\n__Stringifier#header(comment) : Stringifier__\r\n\r\nWrites a header comment. It will be written to the top of the final string. Returns the Stringifier being used.\r\n\r\n<a name=\"Stringifier_property\"></a>\r\n__Stringifier#property(obj) : Stringifier__\r\n\r\nWrites a property line. It takes an object with three options: `key`, `value` and `comment`. Both the key and the value are converted into a string automatically. Returns the Stringifier being used.\r\n\r\n```javascript\r\nstringifier\r\n  //No value\r\n  .property ({ key: \"a\" })\r\n  .property ({ key: \"b\", value: [1, 2, 3] })\r\n  //No key and no value\r\n  .property ({ comment: \"empty\" })\r\n\r\n/*\r\na = \r\nb = 1,2,3\r\n# empty\r\n = \r\n*/\r\n```\r\n\r\n<a name=\"Stringifier_section\"></a>\r\n__Stringifier#section(obj) : Stringifier__\r\n\r\nWrites a section line. It gets an object with two options: `name` and `comment`. The name is converted into a string. If you don't need to write a comment, you can pass the name instead of an object. Returns the stringifier being used.\r\n\r\n```javascript\r\nstringifier.section (\"my section\");\r\n\r\n/*\r\n[my section]\r\n*/\r\n\r\nstringifier.section ({ name: \"my section\", comment: \"My Section\" });\r\n\r\n/*\r\n# My Section\r\n[my section]\r\n*/\r\n```\r\n\r\nLook at the [stringify-ini](https://github.com/gagle/node-properties/blob/master/examples/ini/stringify-ini.js) example for further details.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/gagle/node-properties/issues"
  },
  "homepage": "https://github.com/gagle/node-properties",
  "_id": "properties@1.2.1",
  "_shasum": "0ee97a7fc020b1a2a55b8659eda4aa8d869094bd",
  "_from": "properties@",
  "_resolved": "https://registry.npmjs.org/properties/-/properties-1.2.1.tgz"
}
