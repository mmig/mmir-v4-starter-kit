<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

	<title>Semantic Parser Test</title>

	<!--
		Copyright (C) 2012-2013 DFKI GmbH
		Deutsches Forschungszentrum fuer Kuenstliche Intelligenz
		German Research Center for Artificial Intelligence
		http://www.dfki.de

		Permission is hereby granted, free of charge, to any person obtaining a 
		copy of this software and associated documentation files (the 
		"Software"), to deal in the Software without restriction, including 
		without limitation the rights to use, copy, modify, merge, publish, 
		distribute, sublicense, and/or sell copies of the Software, and to 
		permit persons to whom the Software is furnished to do so, subject to 
		the following conditions:

		The above copyright notice and this permission notice shall be included 
		in all copies or substantial portions of the Software.

		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
		OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
		MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
		IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
		CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, 
		TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE 
		SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	-->
	
    <link rel="stylesheet" href="mmirf/vendor/styles/jquery.mobile-1.4.3.min.css" />
    
	<!-- script type="text/javascript">
		//disable jQuery Mobiles navigation/history handling (-> allow simple # links within page)
		//NOTE this needs to be done, before jQuery Mobile JS is loaded!
		$(document).on("mobileinit", function(){
			$.mobile.hashListeningEnabled = false;
			$.mobile.pushStateEnabled = false;
			$.mobile.linkBindingEnabled = false;
		});
	</script-->
	
	
	<script type="text/javascript" src="mmirf/vendor/libs/require.js"></script>
	
	<script type="text/javascript">

//declare GrammarConvert-class in global namespace (will be set during initialization);
var GrammarConverter;
var jsl = {};
var GrammarValidator;

(function () {
    
    
    require.config({
		
		config: {
		    'constants': {
		        forBrowser: true
		    }
		},
	
		paths : {
		    
		    // core
	 	    'main': 'mmirf/main'
		    // lib
		    , 'jquery': 'mmirf/vendor/libs/jquery-2.1.3'
		    
		    // globals and AMDs
	 	    , 'constants': 'mmirf/tools/constants'
	 	    , 'commonUtils': 'mmirf/tools/commonUtils'
		    , 'stringExtension': 'mmirf/tools/extensions/StringExtensions'		
		    , 'dictionary': 'mmirf/tools/dictionary'
		    , 'paramsParseFunc': 'mmirf/tools/paramsParseFunc'
			, 'env': 'mmirf/tools/envDetect'
			, 'envInit': 'mmirf/tools/envInit'	
	
		    , 'jqm': 'mmirf/vendor/libs/jquery.mobile-1.4.3'
	
		    // @chsc03 required by contentElement, renderUtils, declared in presentationManager
		    , 'languageManager': 'mmirf/manager/settings/languageManager'
		    , 'configurationManager': 'mmirf/manager/settings/configurationManager'
		    
			//grammar related
			, 'grammarConverter' : 'mmirf/semantic/grammarConverter'
			, 'semanticInterpreter' : 'mmirf/semantic/semanticInterpreter'
			, 'jscc':  'mmirf/vendor/libs/jscc-amd'
			, 'jison': 'mmirf/vendor/libs/jison'
			, 'pegjs': 'mmirf/vendor/libs/peg-0.8.0'
			, 'jsccGen':  'mmirf/env/grammar/jsccGenerator'
			, 'jisonGen': 'mmirf/env/grammar/jisonGenerator'
			, 'pegjsGen': 'mmirf/env/grammar/pegjsGenerator'
			
			, 'grammarValidator' : 'appTestSemantic/jsonGrammarValidator'
			, 'jsonlint': 'appTestSemantic/libs/jsonlint-loc'
			, 'esprima' : 'appTestSemantic/libs/esprima'
		},
	
		shim : {
		    
		      'jqm': ['jquery']
			, 'jsonlint' : {exports: 'jsonlint'}
			, 'pegjs':       	{exports: 'PEG'}
	
		}
    });

	var start = (function(){
			
		require(['jquery', 'constants', 'commonUtils', 'languageManager', 'semanticInterpreter', 'grammarConverter'
		         , 'jsonlint', 'grammarValidator', 'jqm'
					
			], function(
					$, constants, commonUtils,languageManager,semanticInterpreter,grammarConverter
					,jsonlint, grammarValidator
			) {
			
			 GrammarValidator = grammarValidator;
			 
			 $(function() {
			
				 //export dependencies into mmir-package:
				 mmir = {
						 Constants: constants,
						 CommonUtils: commonUtils,
						 LanguageManager: languageManager,
						 SemanticInterpreter: semanticInterpreter
				 };
				 
				 GrammarConverter = grammarConverter;
				 
				 jsl.parser = jsonlint;
				 
				 console.log('dom ready');
	
				 // start commonUtils
				 commonUtils.init()
	
				 	 // start the app
					 .then(function() {
					 
						initJqmBookmarking();
						initPage();				
	
					 });

			 });

	 });
	
	})();

}());

	</script>
		
	<style type="text/css">
		
		.grid {
			display: inline-table;
		}
		.grid-cell {
			display: table-cell;
			vertical-align: bottom;
		}
		
		#language-selection-area .ui-select {
			display: inline;
		}
		
		#outputBox {
			font-family:monospace;
			font-size:12px;
			white-space: pre;
			overflow:scroll;
			border: thin solid lightGrey;
			height: 300px;
			width:100%;
		}
		
		code {
			white-space: pre;
		}
		
		#compileOutBox, #compiledParserOutBox {
			font-family:monospace;
			font-size:12px;
			white-space: pre;
			overflow:scroll;
			border: thin solid lightGrey;
			height: 300px;
			width:100%;
		}
		
		#compiledParserOutBox {
			height: 600px;
		}
		
		#interpretationBox, #interpretationBoxAlt {
			font-family:monospace;
			font-size:12px;
			white-space: pre;
			overflow:scroll;
			border: thin solid lightGrey;
			height: 300px;
			width:100%;
		}
		
		#stopwordBox, #stopwordBox2 {
			font-family:monospace;
			font-size:12px;
			white-space: pre;
			overflow:scroll;
			border: thin solid lightGrey;
			height: 3em;
			width:100%;
		}
	</style>
	
<!-- Test Code -->
<script type="text/javascript">
	
	var IS_DEBUG_ENABLED = true;
	
	var IS_FILE_READING_API = false;
	
	var DEFAULT_EXAMPLE_PHRASE = 'Radio spielen';
	
	var LOADER_THEME = 'b';
	
	if(!console){
		console = new Object();
	}
	if(!console.log){
		console.log = function(msg){ alert(msg);};
	}
	if(!console.debug){
		console.debug = console.log;
	}
	if(!console.info){
		console.info = console.log;
	}
	if(!console.warn){
		console.warn = console.log;
	}
	if(!console.error){
		console.error = console.log;
	}

	var forBrowser = true;
	
	//enable/disable additional processing for stopwords by using an
	//	alternative function for removing stopwords
	var isEnableAlternateStopwordProcessing = false;
	
	var params = document.location.search;
	if( /enable-alt=true/igm.test(params) ){
		isEnableAlternateStopwordProcessing = true;
	}
	
	//if alt-stopword processing is disabled:
	//  hide/remove corresponding GUI elements on page
	//  (and use remaining space for default GUI elements instead)
	if( ! isEnableAlternateStopwordProcessing){
		
		require(['jquery'], function($){
			$(function(){
				$('#altProcInterpretationCol').hide();
				$('#altProcStopwordCol').hide();
				$('#defaultProcInterpretationCol').attr('colspan','2').css('width','50%');
				$('#defaultProcStopwordCol').attr('colspan','2').css('width','50%');
			});
		});
		
	}
	
	require(['pegjs'], function(PEG){
		PEG.printError = _error;
	});
	
	require(['jison'], function(jison){
		jison.printError = _error;
	});
	
	require(['esprima'], function(jsParser){
		
	});
	
	require(['jscc'], function(jscc){
		
		//set print-function of JS/CC so that errors, warnings etc.
		// are outputed into a "text box" on the page
		jscc.set_printError(_error);
		jscc.set_printWarning(_warning);
		jscc.set_printInfo(_print);
	});
	
	var semanticInterpreter;// = mmir.SemanticInterpreter.getInstance();
	//semanticInterpreter.get_json_grammar_url = function(id) { return 'config/languages/'+id+'/grammar.json'; };
	
	//TODO: (1) load directory_strucutre file and detect available JSON grammars, (2) create drop-down menu for languages
	//semanticInterpreter.setCurrentGrammar('de');

	var inputElement;
	var interpretElement;
	var stopwordElement;
	
	var compiledParser;
	var compileCount = 0;
	
	var theJSONGrammarURL = 'un-initialized';//semanticInterpreter.get_json_grammar_url('de');
	var theJSONgrammar = 'un-initialized';
	
	var OPTION_GRAMMAR_FROM_FILE = 'file-option';
	var OPTION_GRAMMAR_FROM_TEXTINPUT = 'textinput-option';
	
	var initPage = function initPageImpl(){
	
		semanticInterpreter = mmir.SemanticInterpreter.getInstance();
		semanticInterpreter.get_json_grammar_url = function(id) { return 'config/languages/'+id+'/grammar.json'; };
		
		var languageManager = mmir.LanguageManager.getInstance();
				
		//get a default/"starting" language
		var defLang = languageManager.getLanguage();
		if( ! languageManager.existsGrammar(defLang)){
			defLang = null;
		}

		//create list with languages for which a grammar is available
		var allLangs = languageManager.getLanguages();
		var langs = [];
		for(var i=0, size = allLangs.length; i < size ; ++i){
			
			if(languageManager.existsGrammar(allLangs[i])){
				langs.push( allLangs[i] );
				
				if(defLang === null){
					defLang = allLangs[i];
				}
			}
			
		}
		
		if(defLang === null){
			defLang = '';
		}
		
		var langMenu = createLanguageMenu(langs, defLang);
		var isLang = function(id){
			for(var i=0,size=langs.length; i < size; ++i){
				if(langs[i] === id){
					return true;
				}
				return false;
			}
		};
		
		$('#grammar-id').val(defLang);
		theJSONGrammarURL = semanticInterpreter.get_json_grammar_url(defLang);
		
		$('#lang-selector-manual-input').hide();
		$('#lang-selector').replaceWith($.parseHTML(langMenu));
		$('#lang-selector').selectmenu({ inline: true });

		$("#lang-selector").on( "change", function(event, ui) {
			
			var prevLang = $('#grammar-id').val();
			
			var currentLangSelection = $(this).val();
			$('#grammar-id').val(currentLangSelection);
			
			theJSONGrammarURL = semanticInterpreter.get_json_grammar_url(currentLangSelection);
			
			var callback = function (isSuccess){
				if(isSuccess){
					
					//if previous selection was loaded-from-file -> remove file entry
					//	 (a new one will be created, next time a grammar is loaded from file or textinput)
					if( !isLang(prevLang) ){
						$('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_FILE+'"]').remove();
						$('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_TEXTINPUT+'"]').remove();
					}
					
					clearInput();
					clearOut();
					clearInterpret();
					clearStopword();
					
					initPageWithJsonGrammar();
				}
				else {
					// loading failed -> "revert" selection
					$('#lang-selector option[value="'+currentLangSelection+'"]').prop('selected', null);
					if( isLang(prevLang) ){
						$('#lang-selector option[value="'+prevLang+'"]').prop('selected', 'selected');
					}
					else {
						//reset to temp-selection entry (either file or from textinput)
						var fileSelection = $('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_FILE+'"]');
						if(fileSelection.length > 0){
							fileSelection.prop('selected', 'selected');
						}
						else {
							$('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_TEXTINPUT+'"]').prop('selected', 'selected');
						}
					}
					
					$('#lang-selector').selectmenu('refresh', true);
					currentLangSelection = prevLang;
					
					$('#grammar-id').val(prevLang);
					
				}
			};
			loadJsonGrammar(callback);
			
		});//END: $("#lang-selector").on( "change"...
				
		//set current language in drop-down-box:
		if(false || defLang){
			var selectedLangOption = $('#lang-selector option[value="'+defLang+'"]');
			if( ! selectedLangOption.is('selected')){
				$('#lang-selector option:selected').prop('selected', null);
				selectedLangOption.prop('selected', 'selected');
			}
			
			$('#lang-selector').selectmenu('refresh', true);
		}
		
		//overwrite default-impl. for getLanguage (-> use grammar-ID-field value instead of input-field's)
		getLanguage = function(){
			return $('#grammar-id').val();
		}
		
		initFileApi();
		
		if(!inputElement) 
			inputElement = document.getElementById("inputBox");
			
		if(!interpretElement) 
			interpretElement = document.getElementById("interpretationInputBox");
			
		if(!stopwordElement) 
			stopwordElement = document.getElementById("stopwordInputBox");
			

		var callback = function(isSuccess){
			if(isSuccess){
				initPageWithJsonGrammar();
			} 
			else {
				$('#file-selector').trigger('click');
			}
		}
		
		loadJsonGrammar(callback);
	};

//	jQuery(document).ready(function(){
//		mmir.CommonUtils.initialize(initPage);
//	});
	
	function getLanguage(){
		var id = $('#lang-selector-field').val();
		$('#grammar-id').val(id);
		return id;
	}
	
	function initPageWithJsonGrammar(){
		
		var doInit = function(){
			
			validateJsonGrammar();
			
			semanticInterpreter = mmir.SemanticInterpreter.getInstance();
			semanticInterpreter.createGrammar(theJSONgrammar, getLanguage(), function(){
			
				printGrammarDefinition();
				printInput(JSON.stringify(theJSONgrammar, null, 2));
				printCompiledParserDefinition();
				
				doProcessEvalErrors(getLanguage());
			
				var examplePhrase;
				if(typeof theJSONgrammar.example_phrase !== 'undefined'){
					examplePhrase = theJSONgrammar.example_phrase;
				}
				else {
					examplePhrase = DEFAULT_EXAMPLE_PHRASE;
				}
			
				interpretElement.value = examplePhrase;
				processInterpretation();
			
			
				_hideLoader();
			});
		};
		
		_showLoader('Compiling JSON Grammar...', 50, doInit);
	}
	
	function _showLoader(text, delay, func, argsArray){
		
		if($.mobile){
			
			if(!delay){
				$.mobile.loading( 'show', {
					text: text,
					theme: LOADER_THEME,
					textVisible: true
				});
			}
			else {
				setTimeout(function(){
					if($.mobile){
						$.mobile.loading( 'show', {
							text: text,
							theme: LOADER_THEME,
							textVisible: true
						});
						setTimeout(function(){ func.apply(null, argsArray) }, delay);
					}
					else {
						func.apply(null, argsArray)
					}
				},50);
			}
		}
	}
	
	function _hideLoader(){
		if($.mobile){
			$.mobile.loading( 'hide' );
		}
	}
	
	function loadJsonGrammar(cb){
		if(!semanticInterpreter){
			semanticInterpreter = mmir.SemanticInterpreter.getInstance();
		}
		
		var successFunc = function(gcInstance){
			if(gcInstance.json_grammar_definition){
				
				theJSONgrammar = gcInstance.json_grammar_definition;
				if(theJSONgrammar['comment_license']){
					delete theJSONgrammar['comment_license'];
				}
				cb(true)
			}
			else{
				cb(false);
			}
		};
		var errorFunc =  function(gcInstance){
			alert("Initialize:\n failed to load JSON grammar file from\n '"+theJSONGrammarURL+"'!");
			cb(false);
		};
		
		var gc = new GrammarConverter();
		
		var doLoadGrammar = function(){
			
			gc.loadGrammar(successFunc, errorFunc, theJSONGrammarURL, false);
			
			_hideLoader();
		};
		
		_showLoader('Loading JSON Grammar...', 50, doLoadGrammar);
		
	}

	function initFileApi() {
		if (window.File && window.FileReader && window.FileList && window.Blob) {
			IS_FILE_READING_API = true;
			$('#file-selector').on('change', loadJsonGrammarFromFile);
		} 
		else {
			$('#file-selector').hide();
		}
	}

	function loadJsonGrammarFromFile(evt) {

		_showLoader('Loading JSON Grammar from file...');
		
	    var files = evt.target.files; // FileList object
	    
	    // Loop through the FileList (should be only one, since "multiple" is not set)
	    for (var i = 0, f; f = files[i]; i++) {

	      var reader = new FileReader();
	      var theFileName = f.name;
	      
	      // Closure to capture the file information.
	      reader.onload = function(theFileEvent) {
				

				var theGrammarId = prompt('Please enter an ID for the grammar:', theFileName);
				if(theGrammarId === null){
					//cancel selected -> do nothing
					return;///////////////////////////// EARLY EXIT ////////////////////////
				}
				
				var prevSel = $('#lang-selector option:selected').val();
				$('#grammar-id').val(theGrammarId);
				
				//update selection menu:
				//	* (if previous selection was a file or compiled from textinput: remove the previous entry)
				//	* create an entry for the file selection
				//	* de-select previous entry
				//	* select the new file-entry (and update selection menu)
				$('#lang-selector  option[value="'+OPTION_GRAMMAR_FROM_FILE+'"]').remove();
				$('#lang-selector  option[value="'+OPTION_GRAMMAR_FROM_TEXTINPUT+'"]').remove();
				
				var fileOptionEntry = createLanguageMenuEntry(theGrammarId, null, null, OPTION_GRAMMAR_FROM_FILE);//lang, menuElem, defaultSelection, value);
				$('#lang-selector').append( $.parseHTML(fileOptionEntry.join('')) );
				
				//de-select previous selection
				$('#lang-selector option[value="'+prevSel+'"]').prop('selected',null);
				
				//select new file-entry
				$('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_FILE+'"]').prop('selected', 'selected');
				//update GUI
				$('#lang-selector').selectmenu('refresh', true);
				
		        clearInput();
		        clearOut();
		        clearInterpret();
		        clearStopword();
		        
				theJSONgrammar = $.parseJSON( theFileEvent.target.result );
				
				if(theJSONgrammar['comment_license']){
					delete theJSONgrammar['comment_license'];
				}
				
				$('#inputBox').val(JSON.stringify(theJSONgrammar, null, 2));
				
				initPageWithJsonGrammar();
				$('#file-selector').val(null);
				
	      };

	      reader.onerror = function(theFileEvent) {
	    	  var msg = '';
	    	  var e = theFileEvent.target.error;

	    	  switch (e.code) {
	    	    case FileError.QUOTA_EXCEEDED_ERR:
	    	      msg = 'QUOTA_EXCEEDED_ERR';
	    	      break;
	    	    case FileError.NOT_FOUND_ERR:
	    	      msg = 'NOT_FOUND_ERR';
	    	      break;
	    	    case FileError.SECURITY_ERR:
	    	      msg = 'SECURITY_ERR';
	    	      break;
	    	    case FileError.INVALID_MODIFICATION_ERR:
	    	      msg = 'INVALID_MODIFICATION_ERR';
	    	      break;
	    	    case FileError.INVALID_STATE_ERR:
	    	      msg = 'INVALID_STATE_ERR';
	    	      break;
	    	    default:
	    	      msg = 'Unknown Error';
	    	      break;
	    	  };

	    	  alert('Error: ' + msg);
	      };
	      
	      // Read in the file as text (UTF-8)
	      reader.readAsText(f);
	    }
	}
	
	function parseInput(){
		
		if( ! inputTextToJSON() ){
			return;
		}
		
		clearOut();
		
		validateJsonGrammar();
		
		semanticInterpreter = mmir.SemanticInterpreter.getInstance();
		
		var langCode = getLanguage();

		if( semanticInterpreter.hasGrammar(langCode) ){
			langCode = prompt('About to replace grammar for:\n'
					+langCode
					+'\n\n\nIf you do not want to replace the grammar\n'
					+      'please enter a different ID:'
				, langCode);
			
			if(langCode === null){
				//-> cancel selected
				return;///////////////////////////// EARLY EXIT ////////////////////////
			}
			else {
				$('#grammar-id').val(langCode);
			}
		}

		//update entries in selection menu if necessary:
		// -> if an entry does not yet exist:
		//    * create a new entry for this grammar-ID
		//    * de-deselect previous selection
		//    * if previous was temporary entry (ie. a file or from the text-input): remove it
		//    * select new entry (and update GUI)
		if( ! semanticInterpreter.hasGrammar(langCode)){
			
			var prevSel = $('#lang-selector option:selected').val();
			
			//remove temporary entries (may not exists)
			$('#lang-selector  option[value="'+OPTION_GRAMMAR_FROM_FILE+'"]').remove();
			$('#lang-selector  option[value="'+OPTION_GRAMMAR_FROM_TEXTINPUT+'"]').remove();
			
			var textinputOptionEntry = createLanguageMenuEntry(langCode, null, null, OPTION_GRAMMAR_FROM_TEXTINPUT);//lang, menuElem, defaultSelection, value);
			$('#lang-selector').append( $.parseHTML(textinputOptionEntry.join('')) );
			
			//de-select previous selection
			$('#lang-selector option[value="'+prevSel+'"]').prop('selected',null);
			
			//select the newly generated entry:
			$('#lang-selector option[value="'+OPTION_GRAMMAR_FROM_TEXTINPUT+'"]').prop('selected', 'selected');
			
			//update GUI
			$('#lang-selector').selectmenu('refresh', true);
			
		}

		var doParseAndCompile = function(){
			semanticInterpreter.createGrammar(theJSONgrammar, langCode, function(){
				printGrammarDefinition();
				printCompiledParserDefinition();
				
				doProcessEvalErrors(langCode);
			
				if(typeof theJSONgrammar.example_phrase !== 'undefined'){
					var examplePhrase = theJSONgrammar.example_phrase;
					interpretElement.value = examplePhrase;
					processInterpretation();
				}
			
				_hideLoader();
			});
		};
		
		_showLoader('Parsing and Compiling JSON Grammar...', 50, doParseAndCompile);

	}
	
	function doProcessEvalErrors(langCode){
		
		var getLocationAsString = function(e){
			return 'line ' + e.lineNumber 
							+ ':' + e.column
							+ '(offset ' + e.index + ')';
		};
		var currentGrammar = semanticInterpreter.getGrammarConverter(langCode);
		if(currentGrammar.executeGrammar.hasErrors){
			var jsParser = require('esprima');
			var text = currentGrammar.getJSGrammar();
			
			try {
				var syntax = jsParser.parse(text, { tolerant: true, loc: true });
	            var errors = syntax.errors;
	            
	            if (errors.length > 0) {
	                _error( 'Invalid JavaScript code for grammar "'+langCode+'". Total issues: ' + errors.length );
	                for (i = 0; i < errors.length; i += 1) {
	                    _error( '    At ' + getLocationAsString(errors[i]) + ': ' + errors[i].description );
	                }
	            }
			} catch (err){
				_error( err.description + ' in JavaScript code for grammar "'+langCode
						+'" at ' + getLocationAsString(err)
				);
				console.error(err);
			}
		}
	}
	
	function processInterpretation(){
		
		var asr_result = interpretElement.value;
		var res  = semanticInterpreter.getASRSemantic(    asr_result.toLowerCase(), getLanguage());
		
		var res2;
		if(isEnableAlternateStopwordProcessing){
			res2 = semanticInterpreter.getASRSemantic_alt(asr_result.toLowerCase(), getLanguage());
		}
		
		clearInterpret();
		
		$('#time').text('');
		$('#time-mod').text('');
		
		printInterpretation(res);
		
		if(isEnableAlternateStopwordProcessing){
			printInterpretationAlt(res2);
		}
		
		stopword(asr_result);
	}
	
	function benchmarkInterpretation(){
		
		var asr_result = interpretElement.value;
		var res  = semanticInterpreter.getASRSemantic(    asr_result.toLowerCase(), getLanguage());
		
		var res2;
		if(isEnableAlternateStopwordProcessing){
			res2 = semanticInterpreter.getASRSemantic_alt(asr_result.toLowerCase(), getLanguage());
		}
		
		clearInterpret();
		
		var DEFAULT_ITERATIONS = 10000;
		var iterations = DEFAULT_ITERATIONS;
		
		iterations = prompt('Starting Benchmark for evaluting Stopword-Processing implementations.'
				+'\n\nWARNING: This may take several minutes.'
				+'\n\nSpecifiy loops for repeat:'
			,iterations
		);
		
		//was cancel selected?
		if(iterations === null){
			return;///////////////////////////// EARLY EXIT ////////////////////////
		}
		
		iterations = parseInt(iterations);
		
		if(isNaN(iterations)){
			iterations = DEFAULT_ITERATIONS;
		}
		
		
		var doStartBenchmark = function(){

			var startTime = new Date();
			for(var i=0; i < iterations; ++i){
				semanticInterpreter.getASRSemantic(    asr_result.toLowerCase(), getLanguage());
			}
			var diffTime = new Date() - startTime;

			$('#time').text(iterations + ' interations in ' + diffTime + ' ms');
			
			if(isEnableAlternateStopwordProcessing){
				var startTimeAlt = new Date();
				for(var i=0; i < iterations; ++i){
					semanticInterpreter.getASRSemantic_alt(asr_result.toLowerCase(), getLanguage());
				}
				var diffTimeAlt = new Date() - startTimeAlt;

				$('#time-mod').text(
						iterations + ' interations in ' + diffTimeAlt
								+ ' ms (alt. method)');
			}
			
			printInterpretation(res);
			
			if(isEnableAlternateStopwordProcessing){
				printInterpretationAlt(res2);
			}
			
			stopword(asr_result);
			
			_hideLoader();
		};
		

		_showLoader('Benchmarking ('+iterations+' loops)...', 50, doStartBenchmark);
		
	}
	
	function stopword(text){
		var sw_result;
		if(typeof text ==='undefined' || text == null){
			sw_result = stopwordElement.value;
		} else {
			sw_result = text;
			stopwordElement.value = sw_result;
		}
		var res  = semanticInterpreter.removeStopwords(   sw_result.toLowerCase(), getLanguage());
		
		var res2;
		if(isEnableAlternateStopwordProcessing){
			res2 = semanticInterpreter.removeStopwords_alt(sw_result.toLowerCase(), getLanguage());
		}
		
		clearStopword();
		printStopword(res, res2);
	}
	
	function printGrammarDefinition(){
		printCompile(semanticInterpreter.getGrammarDefinitionText( getLanguage() ));
	}
	
	function printCompiledParserDefinition(){
		printCompiledParser(semanticInterpreter.getGrammarParserText( getLanguage() ));
	}
	
	function clearInput() {
		$('#inputBox').val('');
	}
	
	function clearOut() {
		var outputBox = document.getElementById("outputBox");
		outputBox.textContent="";
		outputBox = document.getElementById("compileOutBox");
		outputBox.textContent="";
		outputJSBox = document.getElementById("compiledParserOutBox");
		outputJSBox.textContent="";
		clearInterpret();
		clearStopword();
	}
	
	function clearInterpret() {
		var outputBox = document.getElementById("interpretationBox");
		outputBox.textContent="";
		outputBox = document.getElementById("interpretationBoxAlt");
		outputBox.textContent="";
	}
	
	function clearStopword() {
		var outputBox = document.getElementById("stopwordBox");
		outputBox.textContent="";
		outputBox = document.getElementById("stopwordBox2");
		outputBox.textContent="";
	}
	
	function _error(msg) {
		print("ERROR: " + msg);
	}

	function _warning(msg) {
		print("WARNING: " + msg);
	}

	function _print(msg) {
		print("INFO: " + msg);
	}
	
	var print = (function () {
		var outputBox;
		return function(text) {
			text = text.replace(/([^\r])\n/g, "$1\r\n");
			if (!outputBox)
				outputBox = document.getElementById("outputBox");
			if(typeof text == "string") {
				outputBox.appendChild(document.createTextNode(text + "\r\n"));
			} else {
				for(var i=0;i<text.length;i++) {
					outputBox.appendChild(document.createTextNode(text[i]
							+ "\r\n"));
				}
			}
		};
	})();
	
	var printCompile = (function () {
		var outputBoxC;
		return function(text) {
			//text = text.replace(/([^\r])\n/g, "$1\r\n");
			if (!outputBoxC)
				outputBoxC = document.getElementById("compileOutBox");

			outputBoxC.textContent = text + "\r\n";
		};
	})();
	
	var printCompiledParser = (function () {
		var outputBox;
		return function(text) {
			//text = text.replace(/([^\r])\n/g, "$1\r\n");
			if (!outputBox)
				outputBox = document.getElementById("compiledParserOutBox");
			if(typeof text == "string") {
				outputBox.textContent = text + "\r\n";
			} else {
				for(var i=0;i<text.length;i++) {
					outputBox.appendChild(document.createTextNode(text[i]
							+ "\r\n"));
				}
			}
		};
	})();
	
	var printInterpretation = function(text) {
		doPrintInterpretation(text, true);
	};
	
	var printInterpretationAlt = function(text) {
		doPrintInterpretation(text, false);
	};
	
	var doPrintInterpretation = (function () {
		var outputBox1;
		var outputBox2;
		return function(text, inNormalNotAlt) {
			if(typeof text == "object") {
				if(typeof text.semantic === 'string'){
					text.semantic = JSON.parse(text.semantic);
				}
				text = JSON.stringify(text, null, 2);
			} else 
				text = text.replace(/([^\r])\n/g, "$1\r\n");

			if (!outputBox1)
				outputBox1 = document.getElementById("interpretationBox");
			if (!outputBox2)
				outputBox2 = document.getElementById("interpretationBoxAlt");
			
			var outputBox = inNormalNotAlt? outputBox1 : outputBox2;
			
			if(typeof text == "string") {
				outputBox.appendChild(document.createTextNode(text + "\r\n"));
			} else {
				for(var i=0;i<text.length;i++) {
					outputBox.appendChild(document.createTextNode(text[i]
							+ "\r\n"));
				}
			}
		};
	})();
	
	var printStopword = (function () {
		var outputBox;
		var outputBox2;
		return function(text, text2) {
			text = text.replace(/([^\r])\n/g, "$1\r\n");
			if (!outputBox)
				outputBox = document.getElementById("stopwordBox");
			if(typeof text == "string") {
				outputBox.appendChild(document.createTextNode(text + "\r\n"));
			} else {
				for(var i=0;i<text.length;i++) {
					outputBox.appendChild(document.createTextNode(text[i]
							+ "\r\n"));
				}
			}
			
			if(isEnableAlternateStopwordProcessing){
				text2 = text2.replace(/([^\r])\n/g, "$1\r\n");
				if (!outputBox2)
					outputBox2 = document.getElementById("stopwordBox2");
				if(typeof text2 == "string") {
					outputBox2.appendChild(document.createTextNode(text2 + "\r\n"));
				} else {
					for(var i=0;i<text2.length;i++) {
						outputBox2.appendChild(document.createTextNode(text2[i]
								+ "\r\n"));
					}
				}
			}
		};
	})();
	
	var printInput = (function () {
		var outputBox;
		return function(text) {
			//text = text.replace(/([^\r])\n/g, "$1\r\n");
			if (!outputBox)
				outputBox = document.getElementById("inputBox");
			
			if(typeof text !== "string") {
				text = text.join('\r\n');				
			}
			
			$(outputBox).val(text+'\r\n');
			return;
			
			/*
			if(typeof text == "string") {
				outputBox.appendChild(document.createTextNode(text + "\r\n"));
			} else {
				for(var i=0;i<text.length;i++) {
					outputBox.appendChild(document.createTextNode(text[i]
							+ "\r\n"));
				}
			}
			*/
		};
	})();
	
	var selectJsonGrammar = (function () {
		var outputBox;
		return function() {
			if (!outputBox)
				outputBox = document.getElementById('inputBox');
			
			outputBox.select();
		};
	})();
	
	var selectJsjcGrammar = (function () {
		var outputBox;
		return function(text) {
			if (!outputBox)
				outputBox = document.getElementById('compileOutBox');
			
			outputBox.select();
		};
	})();
	
	var selectCompiledCode = (function () {
		var outputBox;
		return function(text) {
			if (!outputBox)
				outputBox = document.getElementById('compiledParserOutBox');
			
			outputBox.select();
		};
	})();
	
	//select the text of a line in a DOM textarea
	var selectLine = (function(){//(domTextArea, lineNo)
		
		/**
		  * Get the start/end position of a selection
		  * in a text-component:
		  * {
		  * 	start: START_INDEX,
		  * 	end:   END_INDEX,
		  * }
		  * 
		  * If no selection is made, the cursor position is returned
		  * (i.e. start === end)
		  */
		 function getSelection(domTextComponent){
			 var startPos;
			 var endPos;
			 // IE version
			 if (document.selection != undefined){
				 domTextComponent.focus();
				 var sel = document.selection.createRange();
				 startPos = sel;
				 endPos = sel;
			 }
			 // Mozilla version
			 else if (domTextComponent.selectionStart != undefined){
				 startPos = domTextComponent.selectionStart;
				 endPos = domTextComponent.selectionEnd;
			 }
			 else {
				 console.error('unknow selection mechanism...');
			 }

			 return {start: startPos, end: endPos};
		 }

		 /**
		  * selects a range in a text-component.
		  * If start === end, an empty selection is made, i.e. the cursor position is set.
		  */
		 function setSelection(domTextComponent, start, end, doRequestFocus){
			 // Mozilla version
			 if (domTextComponent.setSelectionRange) {
				 if(typeof doRequestFocus === 'undefined' || doRequestFocus !== false){
					 domTextComponent.focus();
				 }
				 domTextComponent.setSelectionRange(start, end);
			 }
			 // IE version
			 else if (domTextComponent.createTextRange) {
				 var range = domTextComponent.createTextRange();
				 range.collapse(true);
				 range.moveEnd('character', end);
				 range.moveStart('character', start);
				 range.select();
			 }
			 if(typeof doRequestFocus === 'undefined' || doRequestFocus !== false){
				 domTextComponent.focus();
			 }
		 }
		 
		 //get JSON for start / end position in str for line no. i
		 var getPositionForLine = (function(){//(str, i)
				
				var detectLinebreak = /(\r?\n|\r)/igm;
				
				/**
				 *
				 * Get the index in the String str, where line number lineNo
				 * starts.
				 * 
				 * New lines begin after \n, \r\n, or \r.
				 * 
				 * If lineNo is <= 1, the function returns always 0.
				 * 
				 * If the lineNo is greater than the count of lines in str, the string length itself is returned. 
				 * 
				 * @function getIndexForLine
				 * @param {String} str the string
				 * @param {Number} lineNo the line number (first line is 1)
				 * 
				 */
				var getStart = function(str, lineNo){
					if(lineNo <= 1){
						return 0;
					}
					var match;
					var count = 1;
					while(match = detectLinebreak.exec(str)){
						//ASSERT: lineNo >= 2
						if(++count == lineNo){
							break;
						}
					}
					
					//reset regexpr:
					detectLinebreak.lastIndex = 0;
					
					if(match){
						return match.index + match[1].length;
					}
					
					//request line-no. >= 2 AND loop "detect enough" linebreaks => the request line index starts after strings ends => return string's length
					return str.length;
				};
				
				return function(str, i){
					var start = getStart(str, i);
					
					var end = str.length;
					if(start < end){
						detectLinebreak.lastIndex = start;
						var match;
						if(match = detectLinebreak.exec(str)){
							end = match.index;
						}
						detectLinebreak.lastIndex = 0;
					}
					
					return {start: start, end: end};
				};
			})();//END: getPositionForLine
			
			
			return function selectLineImpl(theTextArea, line){
				var $ta = $(theTextArea);
				var ta = $ta[0];
				
				var str = $ta.val();
				
				var pos = getPositionForLine(str, line);
				
				console.log('selectLine(%s) -> ', line, pos);
				
				setSelection(ta, pos.start, pos.end, true);
			}
	})();
	
	function maskJsonValues(){
		
		if( ! inputTextToJSON() ){
			return;
		}
		
		var converter = new GrammarConverter();
		theJSONgrammar = converter.maskJSON(theJSONgrammar);
		

		clearInput();
		printInput(JSON.stringify(theJSONgrammar, null, 2));
	}
		
	function unmaskJsonValues(){
		if( ! inputTextToJSON() ){
			return;
		}
		
		var converter = new GrammarConverter();
		theJSONgrammar = converter.unmaskJSON(theJSONgrammar);
		

		clearInput();
		printInput(JSON.stringify(theJSONgrammar, null, 2));
	}
	
	function convertFromOldJSONFormat(){
		if( ! inputTextToJSON() ){
			return;
		}
		
		var converter = new GrammarConverter();
		theJSONgrammar = converter.recodeJSON(theJSONgrammar, converter.decodeUmlauts);
		

		clearInput();
		printInput(JSON.stringify(theJSONgrammar, null, 2));
	}
	
	function convertToOldJSONFormat(){
		if( ! inputTextToJSON() ){
			return;
		}
		
		var converter = new GrammarConverter();
		theJSONgrammar = converter.recodeJSON(theJSONgrammar, converter.encodeUmlauts);
		

		clearInput();
		printInput(JSON.stringify(theJSONgrammar, null, 2));
	}
	
	function inputTextToJSON(){
		var text = inputElement.value;
		//console.info('gammar-text: \n'+text);
		try{
			theJSONgrammar = JSON.parse(text);
		} catch(error){
			
			console.error('error: '+error.stack);
			
			var msg = error.toString();
			
			//try to get more details for the error using the json-lint parser:
			try {
				
				var result = jsl.parser.parse(text);

				if (result) {
					msg += '\n\nsuccess:\n'+ JSON.stringify(result,null,2);
				}

			} catch (err) {
				msg = err.toString();
			}
			
			var selectErrorLine = (function(msg){
				//msg text -> e.g.:		Error: Parse error on line 5:
				//							...",    "switch"    "turn",    "turned"
				//						---------------------^
				//						Expecting 'EOF', '}', ':', ',', ']', got 'STRING'
				var detectLineNo = /on line (\d+):/igm;
				var match = detectLineNo.exec(msg);
				
				var lineNo;
				if(match){
					lineNo = match[1];
				}
				
				return function(){
					selectLine(inputElement, lineNo);
					setTimeout(function(){
						selectLine(inputElement, lineNo);
					}, 500);
				};
				
			})(msg);
			selectErrorLine();
			
			//show error in Error/Warining box
			clearOut();
			print(msg.replace(/\^\r?\n/igm, '^ \n'));//<- one "marker" at the line end gets removed -> add a space before linebreak
			
			setTimeout(function(){
				showError(
					'Error',
					'Error on parsing grammar text into a JSON object.',
					'<pre>'+msg+'</pre>',
					selectErrorLine,
					selectErrorLine
			 	);
			}, 100);
			return false;
		}
		
		return true;
	}
	
	function validateJsonGrammar(){
		var validator = new GrammarValidator(theJSONgrammar);
		
		var problems = validator.validateStructure();

		var problems2 = validator.validateIdDuplicates();
		var problems3 = validator.validateTokenDuplicates();
		var problems4 = validator.validateUtteranceDuplicates();
		
		var list = problems.concat(problems2, problems3, problems4);
		if(list.length){
			print('Validation errors for JSON grammar:\n--------------\n'
					+list.map(function(v){ return '  ' + v.toString();}).join('\n') + '\n--------------\n'
			);
		}
	}
	
	function createLanguageMenu (arrayLang, defaultSelection){
		
		var menuElem = ['<label for="lang-selector" data-inline="true">Lanuage: </label>',
							'<select name="lang-selector" id="lang-selector">'
						];
		
		if(!defaultSelection){
			menuElem.push('<option>Lanuage</option>');
		}
		
		for(var i=0,size = arrayLang.length; i < size; ++i){
			var lang = arrayLang[i];
			
			createLanguageMenuEntry(lang, menuElem, defaultSelection);
		}
		
		menuElem.push('</select>');
		
		return menuElem.join('');
	}
	
	function createLanguageMenuEntry (lang, menuElem, defaultSelection, value){
		if(!menuElem){
			menuElem = [];
		}
		
		menuElem.push('<option value="');
		if(value){
			menuElem.push(value);
		}
		else {
			menuElem.push(lang);
		}
		
		menuElem.push('"');
		//if(defaultSelection === lang){//for defaultSelection -> initial selection
			//menuElem.push(' data-placeholder="true"');
		//}
		menuElem.push('>');
		menuElem.push(lang);
		menuElem.push('</option>');
		
		return menuElem;
	}
	
	function showError(title, caption, text, onOpenFunc, onCloseFunc){
		
		var dlg = $( "#parseErrorPopup" );
		
		if(!title){
			title = '';
		}
		if(!caption){
			caption = '';
		}
		if(!text){
			text = '';
		}
		
		$('#parseErrorPopupTitle', dlg).html(title);
		$('#parseErrorPopupCaption', dlg).html(caption);
		$('#parseErrorPopupText', dlg).html(text);
		
		if(onOpenFunc){
			dlg.one( "popupafteropen", onOpenFunc);
		}
		if(onCloseFunc){
			dlg.one( "popupafterclose", onCloseFunc);
		}
		
		dlg.popup( "open" )
	}
	</script>
	
	<script type="text/javascript">
	
	//manually implement bookmark-navigation
	// (by default jQuery Mobile interprest bookmarks as dialogs etc. ...)
//	$(function(){
	function initJqmBookmarking(){
		var links = $('a[href^="#"]');

		$('a[href^="#"]').on('click', function(evt){
			var tis = $(this);
			
			//do not 
			if(tis.data('rel') || tis.attr('href') === '#')
				return true;

			var targetLink = tis.attr('href');
			var target = $(targetLink);
			if(target.length === 0){
				var targetName = targetLink.substring(1);
				target = $('[name="'+targetName+'"]');
			}
			var pos = target.offset();
			
			window.scrollTo(pos.left, pos.top);
			
			return false;
		});

	}
//	);
		
	</script>
	
</head>

<body>


<!-- ################### Popup dialog: ################################# -->				
	<div data-role="popup" id="parseErrorPopup" data-overlay-theme="a" data-theme="a" data-dismissible="false" class="ui-corner-all">
	    <div data-role="header" data-theme="a" class="ui-corner-top">
	        <h1 id="parseErrorPopupTitle">a short title</h1>
	    </div>
	    <div data-theme="a" class="ui-content ui-corner-bottom ui-content">
	        <h3 class="ui-title" id="parseErrorPopupCaption">short description or question.</h3>
	        <p id="parseErrorPopupText">detailed description.</p>
	        <a href="#" data-role="button" data-inline="true" data-rel="back" data-theme="b">OK</a>
	    </div>
	</div>

<!-- ##################################### SECTION: Introduction / heading  ######################################## -->
    
    <a name="top"></a>
    <h1>Semantic Parser Test: Grammar Compiler</h1>
    
    <div style="font-size: 0.9em;width: 100%; white-space: normal !important;">
    <strong>NOTE:</strong>
		On initial load of the page, the <tt>Language</tt> list 
    	is loaded from the file <code>config/directories.json</code>: for each found language
    	directory (<code>config/languages/</code>),	an entry is generated -- on selection, the
    	corresponing JSON file is attempted to be read and compiled.<br/>
    	<i>Note, that there may not be a JSON file for the lanuage available -- in this case an
    	 error message will be shown on selection.</i><br/>
    	
    	<p>You can use the file selector, for loading a JSON grammar from  the local file system</p>
    	
    	<p>Alternatively, you can enter (e.g. copy&paste) a JSON-formatted grammar into the 
    	<i>JSON Grammar Definition</i> field and then press the <i>parse</i> button.</p>
    	<br/>
    </div>
    
    <hr/>
		    		
    <div>
	    <h5  style="display:inline"> TOC: </h5>
	    <fieldset data-role="controlgroup" data-mini="true" data-type="horizontal" style="display:inline;padding-left:2em;">	
	    			<a class="ui-btn ui-corner-all ui-btn-b ui-icon-arrow-d ui-btn-icon-left" href="#json-grammer">JSON Grammar</a>
	    			<a class="ui-btn ui-corner-all ui-btn-b ui-icon-arrow-d ui-btn-icon-left" href="#interpreter-tester">TEST interpretation</a> 
	    			<a class="ui-btn ui-corner-all ui-btn-b ui-icon-arrow-d ui-btn-icon-left" href="#stopword-tester">TEST stopword processing</a>
	    			<a class="ui-btn ui-corner-all ui-btn-b ui-icon-arrow-d ui-btn-icon-left" href="#jsjc-grammar">JS/JC Grammar</a>
	    			<a class="ui-btn ui-corner-all ui-btn-b ui-icon-arrow-d ui-btn-icon-left" href="#compiled-parser">Compiled parser code</a>
	    </fieldset>  
    </div>
    <hr/>
    
<!-- ##################################### SECTION: JSON Grammar Definition  ######################################## -->
    
	<div class="ui-body-d" style="float:right;padding:1em;margin:0.5em;">
		<h4>Load Grammar Options: </h4>
		<div id="language-selection-area" class="grid-cell">
			<div id="lang-selector-manual-input">
				<label for="lang-selector-field">Language:</label> 
				<input type="text" id="lang-selector-field" />
			</div>
			<div id="lang-selector" style="display:none;"></div>
		</div>
		<div class="grid-cell">
			<input type="file" id="file-selector" accept="text" name="files[]" />
		</div>
	</div>
	
    
	<a name="json-grammar"></a>
	<div style="float:left;" class="grid">
    	<div class="grid-cell" style="vertical-align: middle;padding-right:3em;">
    		<a href="#top" class="ui-link ui-btn ui-btn-b ui-icon-arrow-u ui-btn-icon-left ui-shadow ui-corner-all ui-mini">top</a>
    	</div>
		<div class="grid-cell">
    		<h2>JSON Grammar Definition:</h2> 
    	</div>
	</div>
	
	<div style="clear:both;"></div>
		
    <div style="float:left; width: 70%;">
	    <h5>JSON grammar definition:</h5>
		<textarea id="inputBox" rows="20" style="width: 100%;height:300px;" data-role="none" data-enhance="false"></textarea><br/>
		
		<div style="float:left;">
			<input type="button" onclick="selectJsonGrammar();" value="Select All" style="right:0;"/>
		</div><div style="float:right;"  class="grid">
			
			<div class="grid-cell">
				<input type="button" onclick="parseInput();" value="Parse"/>
			</div>
			
			<fieldset class="grid-cell" style="padding-left:0.2em;">
				<label for="grammar-id">Grammar ID:</label>
				<input id="grammar-id" type="text" data-inline="true"/>
			</fieldset>
			
			<div class="grid-cell" style="vertical-align:middle">
				<a href="#popupGrammarIdInfo" 
					class="ui-link ui-btn ui-btn-a ui-icon-info ui-btn-icon-notext ui-btn-inline ui-shadow ui-corner-all" 
					data-rel="popup" 
					data-role="button" 
					data-inline="true" 
					data-transition="pop">
					 
					Grammar ID information
				</a>
				<div data-role="popup" id="popupGrammarIdInfo" class="ui-content" data-theme="a" style="max-width:350px;">
				  <p>The <strong>Grammar ID</strong> 
				  	is internally used to identify the grammar, that is, 
				  	the ID is used to manage multiple grammars.<br/>
				  	If a grammar with the same ID already exists, it will replaced.<br/>
				  </p>
				</div>
			</div>
			
			<div class="grid-cell" style="padding-left:2em;"><div data-role="collapsible" data-collapsed="true">
			   <h3>JSON Grammar Tools</h3>
			   <p>
			   
				<div style="padding-left:2em;float:left;">
					<fieldset data-role="controlgroup" data-type="horizontal">
						<input type="button" onclick="maskJsonValues()" value="mask"/>
						<input type="button" onclick="unmaskJsonValues()" value="unmask"/>
					</fieldset>
				</div>
				<div class="grid-cell" style="vertical-align:middle">
					<a href="#popupMaskingInfo" 
						class="ui-link ui-btn ui-btn-a ui-icon-info ui-btn-icon-notext ui-btn-inline ui-shadow ui-corner-all"
						data-rel="popup" 
						data-role="button" 
						data-inline="true" 
						data-transition="pop">
						 
						Masking information
					</a>
					<div data-role="popup" id="popupMaskingInfo" class="ui-content" data-theme="a" style="max-width:350px;">
					  <p><h3>Preview masking (for non-ASCII characters)</h3>
					    
					    If the JSON values contain <strong>unicode</strong>
					  	characters (i.e. non-ASCII chars), they will get <em>masked</em> before creating
					  	the JS/CC definition, and compiling the executable JavaScript grammar.
					  	<br/><br/>
					  	You can preview the effects of <em>masking</em> by using
					  	<strong>mask</strong> and <strong>unmask</strong>.
					  	<br/><br/>
					  	
					  	<strong>NOTE</strong> that the grammar will not be able
					  	to detect tokens that correspond to the masking pattern itself,
					  	e.g. the token <code>~~751F~~</code> will not be detected, but
					  	instead its <em>unmasked</em> representation <code>&#x751F;</code>.
					  	<br/><br/>
					  </p>
					</div>
				</div>
				
				<div id="format-converter" style="padding-left:2em;float:left;">
					<fieldset data-role="controlgroup" data-type="horizontal">
						<input type="button" onclick="convertFromOldJSONFormat()" value="upgrade"/>
						<input type="button" onclick="convertToOldJSONFormat()" value="downgrade"/>
					</fieldset>
				</div>
				<div class="grid-cell" style="vertical-align:middle">
					<a href="#popupFormatConversionInfo" 
						class="ui-link ui-btn ui-btn-a ui-icon-info ui-btn-icon-notext ui-btn-inline ui-shadow ui-corner-all"
						data-rel="popup" 
						data-role="button" 
						data-inline="true" 
						data-transition="pop">
						 
						Upgrade information
					</a>
					<div data-role="popup" id="popupFormatConversionInfo" class="ui-content" data-theme="a" style="max-width:600px;">
					  <p><h3>Upgrading old umlaut-encoded JSON grammars</h3>
					     
					  	 The old file format for JSON grammars used a special masking
					     for non-ASCII umlauts (e.g. &#246; or &#196;; also for &#223;).
					     <p>
					     For example:
					     <code>&#246;</code> &rarr; <code>__oe__</code>
					     </p>
					     <p>
					     The <b>old</b> file format was targeted at ASCII encoded files which
					     required that the masking was already used in the JSON files
					     themselves.
					     <br/>
					     For example:
	<pre> "stop_word": [
	    "ich",
	    "m__oe__chte",
	    ...</pre>
					     </p>
					     <p>
					     The <b>new</b> file format internally uses a generic masking for all
					     non-ASCII characters. But more importantly, it targets UTF-8
					     encoded files which allows using (almost all) unicode characters
					     directly within the JSON files; i.e. <b>no masking</b> in the 
					     files themselves is required.
					     <br/>
					     For example:
	<pre> "stop_word": [
	    "ich",
	    "m&#246chte",
	    ...</pre>
	    				 or alternatively with new masking:
	<pre> "stop_word": [
	    "ich",
	    "m~~00F6~~chte",
	    ...</pre>
	    				 
					     </p>
					     <p>
					     Unfortunately the new masking-mechanism is incompatible with 
					     the old one, i.e. JSON files which contain the old masking 
					     will not work correctly with the new masking.
					     <br/>
					     As a result, old-style formatted JSON files (with masking)
					     must be converted, i.e. old-style masking must be revered
					     (unmasked) so that the either no masking is done or,
					     alternatively, the new masking style may be used, too.
					     </p>
					     <p>
					     For this purpose, the <b>upgrade</b> button will convert 
					     old-style masked umlauts back to the unmasked, original
					     umlauts; and the <b>downgrade</b> button will reverse that
					     effect (i.e. apply old-stlye masking).
					     </p>
					     
					  </p>
					</div>
				</div>
			</p>
		</div></div>
			
		</div>
		<div style="clear:both;"></div>
		
		<!-- input type="button" onclick="clearOut();" value="Clear"/-->
		
		<br/>
    </div>
    <div style="float:right; width: 27%;">
	    <h5>Output/Error:</h5>
	    <div id="outputBox"></div>
    </div>
	
	<div style="clear: both;"></div>
    
<!-- ##################################### SECTION: Semantic Parser Test: Interpertation  ######################################## -->
    
    <div style="float:left; clear: left; width: 100%;"><div style="clear: right; width: 100%;">
	
		<table width="100%" border="0">
			<tr>
				<td colspan="3">
					<hr/>
					<a name="interpreter-tester"></a><br/>
					<div style="float:left;" class="grid">
				    	<div class="grid-cell" style="vertical-align: middle;padding-right:3em;">
				    		<a href="#top" class="ui-link ui-btn ui-btn-b ui-icon-arrow-u ui-btn-icon-left ui-shadow ui-corner-all ui-mini">top</a>
				    	</div>
						<div class="grid-cell">
							<h2>Semantic Parser Test: Interpertation</h2>
				    	</div>
					</div>
				</td>
			</tr>
			<tr>
				<td valign="top">
					<h5>TEST Interpret Sentence:</h5>
					<textarea id="interpretationInputBox" rows="1" cols="30"></textarea>
					<br/>
					<input type="button" onclick="processInterpretation();" value="Interpret"/>
					<br/>
					<input type="button" onclick="benchmarkInterpretation();" value="Benchmark"/>
					<br/>
					<span id="time"></span>
					<br/>
					<span id="time-mod"></span>
				</td>
				<td valign="top" id="defaultProcInterpretationCol">
					<h5>Interpreter Result:</h5>
					<div id="interpretationBox"></div>
				</td>
				<td valign="top" id="altProcInterpretationCol">
					<h5>Alternate Interpreter Result:
						<span style="font-size:x-small;font-weight: lighter;">
							(using alternate method for stopword removal)
						</span>
					</h5>
					<div id="interpretationBoxAlt"></div>
				</td>
			</tr>
			<tr>
				<td colspan="3">
					<hr/>
					<a name="stopword-tester"></a><br/>
					
					<div style="float:left;" class="grid">
				    	<div class="grid-cell" style="vertical-align: middle;padding-right:3em;">
				    		<a href="#top" class="ui-link ui-btn ui-btn-b ui-icon-arrow-u ui-btn-icon-left ui-shadow ui-corner-all ui-mini">top</a>
				    	</div>
						<div class="grid-cell">
							<h2>Semantic Parser Test: Stopword</h2>
				    	</div>
					</div>
				</td>
				
			</tr>
			<tr>
				<td valign="top">
					<h5>TEST Process Stopwords:</h5>
					<textarea id="stopwordInputBox" rows="1" cols="30"></textarea>
					<br/>
					<input type="button" onclick="stopword();" value="Apply Stopwords"/>
				</td>
				<td valign="top" id="defaultProcStopwordCol">
					<h5>Stopword Result:</h5>
					<div id="stopwordBox"></div>
				</td>
				<td valign="top" id="altProcStopwordCol">					
					<h5>Stopword Result 
							<span style="font-size:x-small;font-weight: lighter;">
								(alternative stopword processing method)
							</span>:
					</h5>
					<div id="stopwordBox2"></div>
				</td>
			</tr>
		</table>
		
		<hr/>


<!-- ##################################### SECTION: JS/JC Grammar Definition ######################################## -->
    
		
		<div>
			<a name="jsjc-grammar"></a>
		    <div style="float:left;" class="grid">
		    	<div class="grid-cell" style="vertical-align: middle;padding-right:3em;">
		    		<a href="#top" class="ui-link ui-btn ui-btn-b ui-icon-arrow-u ui-btn-icon-left ui-shadow ui-corner-all ui-mini">top</a>
		    	</div>
		    	<div class="grid-cell">
		    		<h2>JS/JC Grammar Definition (generated from JSON grammar):</h2>
		    	</div>
		    </div>
			<div style="clear:both;"></div>
		    	
		    <p>This is the specification of grammar in <a target="jscc" href="http://jscc.phorward-software.com/">JS/CC</a> syntax</p>
			<textarea  id="compileOutBox" readonly="readonly"></textarea>
			
			<div style="float:left;">
				<input type="button" onclick="selectJsjcGrammar();" value="Select All"/>
			</div>
			<div style="clear:both;"></div>
		</div>
		
		<hr/>

<!-- ##################################### SECTION: Compiled Parser Code (JavaScript) ######################################## -->
    
		<div style="width: 100%;">
		
			<a name="compiled-parser"></a>
		
		    <div style="float:left;" class="grid">
		    	<div class="grid-cell" style="vertical-align: middle;padding-right:3em;">
		    		<a href="#top" class="ui-link ui-btn ui-btn-b ui-icon-arrow-u ui-btn-icon-left ui-shadow ui-corner-all ui-mini">top</a>
		    	</div>
		    	<div class="grid-cell">
					<h2>Compiled Parser Code:</h2>
		    	</div>
		    </div>
			<div style="clear:both;"></div>
			
			<p>	
				This is the compiled JavaScript code for the grammar.
			</p>
			<p>
				This code can be copied into a file: on loading (i.e. interpreting)
				the JavaScript file, the grammar will be registered with the
				<tt>SemanticInterpreter</tt> for the <em>Grammar ID</em> that is specified above
				in the <a href="#json-grammar">Grammar Definition</a> section.
			</p>
			<div>
				The default location for the compiled JavaScript grammar files is
				<pre style="display:inline;">assets/www/gen/grammar/[Grammar ID]_grammar.json</pre>
			</div>
			<br/>
			
			<div style="float:left;">
				<input type="button" onclick="selectCompiledCode();" value="Select All"/>
			</div>
			<div style="clear:both;"></div>
			
			<textarea id="compiledParserOutBox" readonly="readonly"></textarea>
		</div>
    </div></div>
	
</body>
</html>                                                                                                                                                                            